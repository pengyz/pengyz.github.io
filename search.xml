<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Emacs or Vim? Just spacemacs !</title>
    <url>/2017/06/17/Emacs-or-Vim-Just-spacemacs/</url>
    <content><![CDATA[<p>其实很早之前就接触过emacs，大概是被<strong>Dr. 王垠</strong>蛊惑到了，也许是自己本来就喜欢一些比较geek的东西来折腾，那时候开始尝试使用emacs。也学习过emacs的elisp，写过简单的函数，自己写过配置文件，但是自己主要的工作还是要在windows下完成，开发工具也主要是使用VS，所以emacs也就逐渐沦为了写org的工具。接触VIM大概是在大学的计算机课程上，彻底地被VIM的模式搞昏了头并对此深恶痛绝。</p>
<p>第一次打开emcas运行，还是挺失望的：丑陋的界面，简陋的功能，古怪的快捷键。它在我看来就像是上个世纪的产品，属于那些行将就木的垂垂老朽。但是还是耐下性子，从toturial开始一点点学起，尝试去记忆emcas的快捷键，学习它的buffer，window，mini buffer等等的概念。说实话，emacs能够满足每个diy狂人内心的渴望。有段时间还是挺沉迷emacs的，喜欢尝试各种的配置，在网上四处寻找个各种的配置，尝试给emacs套上各种的功能，把emacs配置成C++ IDE，配置成音乐播放器前端，配置成强大的terminal前端等等。期间也学了一点简单的elisp的编写，尝试自己对emacs进行更深度的定制。不得不说，elisp在我看来是一个古怪的语言，古怪的语法，古怪的括号嵌套，古怪的编程理念，其间种种都和自己接受过的编程概念格格不入。也许是自己实在不是一个能够沉下心来学习的人，始终无法掌握elisp语言的精髓。慢慢的发现，对emacs的研究仿佛永无止境，在lisp的大海里徜徉，却很少感受到自己有什么进步，逐渐也就失去了继续深入的动力。</p>
<span id="more"></span>

<p>也许我用emacs最多的就是在windows下使用org-mode写一些简单的笔记文章。不得不说，org-mode确实是一种不可多得的文档书写工具，使用一些足够简单的纯文本语法就可以渲染出丰富的，排版精美的文档，而且可以方便地转换为html，pdf等其它流行格式。但是不得不说，我还是一个重度依赖windows和vs的开发者，emacs上学习到的技能长期得不到运用，也就逐渐生疏了。当然，emcas本身复杂的学习曲线和繁杂的配置方式抬高了这个工具的使用门槛。和它的竞争对手vim相比，emacs其实是处于弱势地位的，相比vim，它明显太重了，当插件多了以后，启动缓慢。发行版没有预装，需要经过额外的配置才能使用，再加上vim的切模式操作比之emacs的组合快捷键来的高效，emacs始终没有vim流行。而且图形界面下，也有很多的富文本编辑器非常好用，比如sublime，vscode等，也是vim/emacs的强力竞争者。</p>
<p>但是这并不能说明emacs已经过时。它仍然是一个功能异常丰富，设计思路独特的编辑器。把整个编辑器构建于lisp语言之上，不得不说，这是一个天才的构想。emacs功能强大的根源在于，它是一套完整的lisp执行环境， 在它编辑器的外表之下，隐藏者一个完整的脚本运行时环境。它到目前为止都是这个世界上可定制性最强的文本编辑器，你要做的就是精通elisp并针对emacs进行编程，当然，这并不容易。配置emacs的过程，其实就是使用elisp进行编程的过程，所以emacs的配置其实有着很高的门槛。也许在它刚刚被创造出来时，lisp是一种有足够受众的语言，但是时至今日，lisp，或者说lisp的方言elisp，已经是一门难以掌握的小众语言了，这更增加了用户配置emacs的难度。</p>
<p>长久以来，emacs并没有一套足够简单的，开箱即用的通用配置。emacs的灵魂是充分的diy个性化定制，但是在当今这个浮躁的社会，人们需要的更多的是一套足够stupid的配置，能让他们更简单地投入使用。github上有一些大神的配置，但是感觉上还是不够直观，需要额外的学习成本。直到后来，spacemacs出现了，它是一套完整的，开箱即用的，经过良好组织和标准化的配置，它很好地结合了emacs的强大可定制功能和vim的快速操作方式，独创的leader key方式，大量经过配置并充分测试的layer为emacs的功能组织划分了独立的层次结构，更加方便人们的模块定制。可以这么说，spacemacs是一套功能丰富的emacs配置框架，或者你可以理解为elisp编程框架也未尝不可。当然，这个框架唯一的作用就是来配置emacs，听起来似乎跟<strong>编程框架</strong>的说法不符。</p>
<p>spacemacs的另一个亮点功能便是通过完善的分类，将emacs繁杂的快捷键分门别类地整理，方便人们记忆各种复杂的快捷键。比如 space + f + e + d可以打开.spacemacs配置文件。这里space是leader key，用来触发spacemacs里的快捷键序列。f指文件，e指和emacs相关的文件，d是dotfile的缩写，指emacs的配置文件，在这里就是~/.spacemacs文件。再比如space + b + d,b是buffer，里面是所有和buffer相关的操作，d是delete，这个快捷键组合可以删除当前buffer，而大写的D则是close other buffer。当然，你还可以通过space + h 触发所有的帮助功能,emacs会显示全部可用的快捷键提示并配合简单的说明，让你可以尽快找到你需要的功能。通过这种分类之后，新手便可通过猜想的方式去查询自己需要功能的快捷键，比如跟窗口相关的功能应该在space + w快捷序列之下。</p>
<p>另外，如果需要配置额外的插件，spacemacs提供了很多现有的layer以供选择。一个layer可以理解为了实现某个功能而配置的一组插件，用户可以通过启用某个layer来为emacs添加某个特定的功能。比如需要自动完成，可以打开auto-completion层，来启用自动完成功能。具体的配置在.spacemacs的dotspacemacs-configuration-layers中。至于有哪些layer可用，则可以通过space + h + l来查询。spacemacs会通过延迟加载的策略根据所编辑的文件来加载必要的插件，尽最大可能减少emacs的启动时间。</p>
<p>使用spacemacs的evil模式，你可以尽享emacs的强大和vim的便捷。唯一的问题可能是，你需要额外地安装emacs并从github上clone spacemacs项目。spacemacs支持自动升级和插件升级，每次当你配置了新的layer，spacemacs会自动查询需要安装的插件并通过包管理器自动地安装它们。当然，如果你去掉了某个层，spacemacs会在下次启动的时候删除所有无用的插件。</p>
<p>当然，介绍了这么多，希望各位emacs的新手老手能够踊跃尝鲜。社区能贡献出这么有优秀的配置，实在是意见令人高兴的事情。各位emacer，enjoy it！</p>
]]></content>
      <categories>
        <category>Emacs</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>转帖 NAT穿透的详细讲解及分析</title>
    <url>/2017/11/27/NAT%E7%A9%BF%E9%80%8F%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>这是一篇转帖，写的实在精彩。原贴出自<em>看雪论坛</em>，原贴地址请 <a href="http://bbs.pediy.com/thread-131961.htm">戳这里</a> </p>
<p><strong>如果原作者对此转帖行为有任何异议，请联系本人撤销。</strong></p>
<h1 id="什么是NAT？为什么要使用NAT？"><a href="#什么是NAT？为什么要使用NAT？" class="headerlink" title="什么是NAT？为什么要使用NAT？"></a>什么是NAT？为什么要使用NAT？</h1><p>NAT是将私有地址转换为合法IP地址的技术，通俗的讲就是将内网与内网通信时怎么将内网私有IP地址转换为可在网络中传播的合法IP地址。NAT的出现完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。  </p>
<span id="more"></span>

<h2 id="NAT的分类"><a href="#NAT的分类" class="headerlink" title="NAT的分类"></a>NAT的分类</h2><p>STUN标准中，根据内部终端的地址(LocalIP:LocalPort)到NAT出口的公网地址(PublicIP:PublicPort)的映射方式，把NAT分为四种类型：</p>
<ol>
<li>Full Cone NAT: 内网主机建立一个socket(LocalIP:LocalPort) 第一次使用这个socket给外部主机发送数据时NAT会给其分配一个公网(PublicIP:PublicPort),以后用这个socket向外面任何主机发送数据都将使用这对(PublicIP:PublicPort)。此外，任何外部主机只要知道这个(PublicIP:PublicPort)就可以发送数据给(PublicIP:PublicPort)，内网的主机就能收到这个数据包。 </li>
<li>Restricted Cone NAT: 内网主机建立一个socket(LocalIP:LocalPort) 第一次使用这个socket给外部主机发送数据时NAT会给其分配一个公网(PublicIP:PublicPort),以后用这个socket向外面任何主机发送数据都将使用这对(PublicIP:PublicPort)。此外，如果任何外部主机想要发送数据给这个内网主机，只要知道这个(PublicIP:PublicPort)并且内网主机之前用这个socket曾向这个外部主机IP发送过数据。只要满足这两个条件，这个外部主机就可以用自己的(IP,任何端口)发送数据给(PublicIP:PublicPort)，内网的主机就能收到这个数据包。</li>
<li>Port Restricted Cone NAT: 内网主机建立一个socket(LocalIP:LocalPort) 第一次使用这个socket给外部主机发送数据时NAT会给其分配一个公网(PublicIP:PublicPort),以后用这个socket向外面任何主机发送数据都将使用这对(PublicIP:PublicPort)。此外，如果任何外部主机想要发送数据给这个内网主机，只要知道这个(PublicIP:PublicPort)并且内网主机之前用这个socket曾向这个外部主机(IP,Port)发送过数据。只要满足这两个条件，这个外部主机就可以用自己的(IP,Port)发送数据给(PublicIP:PublicPort)，内网的主机就能收到这个数据包。</li>
<li>Symmetric NAT: 内网主机建立一个socket(LocalIP,LocalPort),当用这个socket第一次发数据给外部主机1时,NAT为其映射一个(PublicIP-1,Port-1),以后内网主机发送给外部主机1的所有数据都是用这个(PublicIP-1,Port-1)，如果内网主机同时用这个socket给外部主机2发送数据，NAT会为其分配一个(PublicIP-2,Port-2), 以后内网主机发送给外部主机2的所有数据都是用这个(PublicIP-2,Port-2).如果NAT有多于一个公网IP，则PublicIP-1和PublicIP-2可能不同，如果NAT只有一个公网IP,则Port-1和Port-2肯定不同，也就是说一定不能是PublicIP-1等于 PublicIP-2且Port-1等于Port-2。此外，如果任何外部主机想要发送数据给这个内网主机，那么它首先应该收到内网主机发给他的数据，然后才能往回发送，否则即使他知道内网主机的一个(PublicIP,Port)也不能发送数据给内网主机，这种NAT无法实现P2P通信，但是如果另一方是Full Cone NAT，还是可以实现穿透的，下面我会详细分析各种类型NAT穿透的情况。</li>
</ol>
<p>NAT 功能通常被集成到路由器、防火墙、ISDN路由器或者单独的NAT设备中。所以我们大家很少会知道NAT，上面NAT类型的概念描述是比较通俗的，但为了更便于理解，我再举例阐述一下NAT的原理。</p>
<blockquote>
<blockquote>
<p>现有通信的双方A和B，当A和B都是在公网的时候，通信是不用NAT的。假设A在内网，内网IP是192.168.1.3，端口号是5000，A经过NAT后的IP是221.221.221.100，端口号是8000，B的IP是202.105.124.100，端口是8500。如果B要去主动连接A，即使B知道A经过NAT后的IP和端口也是无法连接成功的，因为A没有向B(202.105.124.100:8500)发送过数据，所以B的数据包会被A的NAT丢弃，于是连接失败。但是A如果去主动连接B，由于B是在公网，所以会连接成功，通信也就会建立。这也就是反弹连接木马“反弹”二字的精髓。<br>当客户端A和B都是处在内网的时候，双方由于都不知道对方的公网IP和端口，就会无从下手，所以要在客户端A和B之间架设一台服务器S来为它们牵线，而且S是处在公网，以保证A和B都能连接到S。客户端A和B登录时都首先连接S，S就会知道A和B经过NAT后的IP和端口，当A想要连接B时，就像S发出请求，S会把B经过NAT后的IP和端口告诉A，同时S向B发送A经过NAT后的IP和端口，并要求B发送数据给A，B发送数据到达A时会被A的NAT抛弃，但是B的NAT会有B发送数据到A的记录，这是A再向B发送数据时就会被B的NAT放行，因为B曾经向A的外网IP和端口发送过数据。</p>
</blockquote>
</blockquote>
<p>可能有点乱，下面以故事的形式叙述一下这个情景。<br>人物：A（男） NAT_A(A家接线员)   B（女） NAT_B  （B家接线员） S<br>场景介绍：A想认识B，但是不知道B的电话，S跟A、B都是朋友，并且知道A和B的电话。接线员的职责：对往外转接的电话不做询问，对往内转接的电话则要过滤以免有骚扰电话。过滤规则：在一定时间内没有拨打过的号码就过滤。</p>
<p>首先A给S打电话：</p>
<pre><code>    A说：我想认识你朋友B，你把她电话给我呗。
    S说：行，她的电话是PublicIP_B，我让她先给你打个电话，要不她家接线员不帮你转接。
    A说：好。
</code></pre>
<p>S跟B打电话：</p>
<pre><code>    S说：我有一个朋友A，人挺好的，他想认识你，你给他打个电话，他的电话号码是PublicIP_A。
    B说：行，打完告诉你。
    S说：好的。
</code></pre>
<p>B打电话到A家，B家接线员NET_B看到女主人想往PublicIP_A打电话就转接到A家了，同时把号码PublicIP_A记录下来，A家接线员NAT_A一看号码是个近期没打过的号，就给挂断了。</p>
<p>B给S打电话：</p>
<pre><code>     B说：我打完电话了
     S说：好，等着吧，一会他就给你打进来了。
</code></pre>
<p>S给A打电话：</p>
<pre><code>     S说：他给你打完电话了，你快点给她打。
</code></pre>
<p>A打电话到B家， A家接线员NET_A看到男主人想往PublicIP_B打电话就转接到B家了，B家接线员NET_B看到是刚刚拨过的PublicIP_A号码打过来的，就转接给B了，A和B的电话也就打通了。<br>A和B通话：</p>
<pre><code>       A说：电话终于打通了，想认识你挺困难的。
       B说：是啊。
</code></pre>
<p>以上虽然和实际不太一样，但穿透的整体过程基本就是这样。A往B发送数据的唯一阻碍就是NET_B，所以想要成功发送数据，必须把NET_B穿一个洞，A是无法完成这项工作的，所以就得让B完成这个打洞操作，也就是让B往A发送数据，这样NET_B就会误以为A发送的数据是上次会话的一部分从而不予阻拦。<br>但是，由于NAT的类型没有一个统一的标准，所以NAT穿透使用的技术有很多种，穿透的成功率也不一样。还有些NAT类型的内网之间几乎无法穿透。下面我们用实例详细分析一下各种NAT类型穿透的可行性。</p>
<p>A机器在私网（192.168.0.3）</p>
<p>A侧NAT服务器（221.221.221.100）</p>
<p>B机器在另一个私网（192.168.0.5）</p>
<p>B侧NAT服务器（210.30.224.70）</p>
<p>C机器在公网（210.202.14.36）作为A和B之间的中介</p>
<p>A机器连接C机器，假使是A（192.168.0.3:5000）-&gt; A侧NAT（转换后221.221.221.100:8000）-&gt; C（210.202.14.36:2000）</p>
<p>B机器也连接C机器，假使是B（192.168.0.5:5000）-&gt; B侧NAT（转换后210.30.224.70:8000）-&gt; C（210.202.14.36:2000）</p>
<p>A机器连接过C机器后，A向C报告了自己的内部地址（192.168.0.3:5000），此时C不仅知道了A的外部地址（C通过自己看到的221.221.221.100:8000）也知道了A的内部地址。同理C也知道了B的外部地址（210.30.224.70:8000）和   内部地址（192.168.0.5:5000）。之后，C作为中介，把A的两个地址告诉了B，同时也把B的两个地址告诉了A。<br>假设A先知道了B的两个地址，则A从192.168.0.3:5000处同时向B的两个地址192.168.0.5:5000和210.30.224.70:8000发包，由于A和B在两个不同的NAT后面，故从A（192.168.0.3:5000）到B（192.168.0.5:5000）的包肯定不通，现在看A（192.168.0.3:5000）到B（210.30.224.70:8000）的包，分如下两种情况：</p>
<ol>
<li>B侧NAT属于Full  Cone  NAT<br> 则无论A侧NAT属于Cone  NAT还是Symmetric  NAT，包都能顺利到达B。如果程序设计得好，使得B主动到A的包也能借用A主动发起建立的通道的话，则即使A侧NAT属于Symmetric  NAT，B发出的包也能顺利到达A。 </li>
</ol>
<blockquote>
<blockquote>
<pre><code> 结论1：只要单侧NAT属于Full  Cone  NAT，即可实现双向通信。    
</code></pre>
</blockquote>
</blockquote>
<ol start="2">
<li>B侧NAT属于Restricted  Cone或Port  Restricted  Cone<br>则包不能到达B。再细分两种情况     </li>
</ol>
<p><strong>(1) A侧NAT属于Restricted  Cone或Port  Restricted  Cone</strong><br>    虽然先前那个初始包不曾到达B，但该发包过程已经在A侧NAT上留下了足够的记录：A（192.168.0.3:5000）-&gt;（221.221.221.100:8000）-&gt;B（210.30.224.70:8000）。如果在这个记录没有超时之前，B也重复和A一样的动作，即向A（221.221.221.100:8000）发包，虽然A侧NAT属于Restricted   Cone或Port Restricted Cone，但先前A侧NAT已经认为A已向B（210.30.224.70:8000）发过包，故B向A（221.221.221.100:8000）发包能够顺利到达A。同理，此后A到B的包，也能顺利到达。     </p>
<blockquote>
<blockquote>
<pre><code> 结论2：只要两侧NAT都不属于Symmetric  NAT，也可双向通信。换种说法，只要两侧NAT都属于Cone  NAT，即可双向通信。     
</code></pre>
</blockquote>
</blockquote>
<p><strong>(2) A侧NAT属于Symmetric  NAT</strong><br>    因为A侧NAT属于Symmetric  NAT，且最初A到C发包的过程在A侧NAT留下了如下记录：A（192.168.0.3:5000）-&gt;（221.221.221.100:8000）-&gt; C（210.202.14.36:2000），故A到B发包过程在A侧NAT上留下的记录为：<br>    A（192.168.0.3:5000）-&gt;（221.221.221.100:8001）-&gt;B（210.30.224.70:8000）（注意，转换后端口产生了变化）。而B向A的发包，只能根据C给他的关于A的信息，发往A（221.221.221.100:8000），因为A端口受限，故此路不通。再来看B侧NAT，由于B也向A发过了包，且B侧NAT属于Restricted   Cone或Port   Restricted  Cone，故在B侧NAT上留下的记录为：B（192.168.0.5:5000）-&gt;（210.30.224.70:8000）-&gt;A（221.221.221.100:8000），此后，如果A还继续向B发包的话（因为同一目标，故仍然使用前面的映射），如果B侧NAT属于Restricted   Cone，则从A（221.221.221.100:8001）来的包能够顺利到达B；如果B侧NAT属于Port  Restricted  Cone，则包永远无法到达B。     </p>
<blockquote>
<blockquote>
<pre><code> 结论3：一侧NAT属于Symmetric  NAT，另一侧NAT属于Restricted   Cone，也可双向通信。     
</code></pre>
</blockquote>
</blockquote>
<pre><code>反过来想，则可以得出另一个结论：
</code></pre>
<blockquote>
<blockquote>
<pre><code> 结论4：两个都是Symmetric NAT或者一个是Symmetric  NAT、另一个是Port Restricted Cone，则不能双向通信，因为NAT无法穿透。     
</code></pre>
</blockquote>
</blockquote>
<p>上面的例子虽然只是分析了最初发包是从A到B的情况，但是，由于两者的对称性，前面得出的几条结论没有方向性，双向都适用。      </p>
<p>我们上面得出了四条结论，natcheck网站则把他归结为一条：<strong>只要两侧NAT都属于Cone  NAT（含Full  Cone、Restricted  Cone和Port  Restricted  Cone三者），即可双向通信。</strong>没有把我们的结论3包括进去。<br>一般情况下，只有比较注重安全的大公司会使用Symmetric NAT，禁止使用P2P类型的通信，很多地方使用的都是Cone  NAT，因此穿透技术还是有发展前景的。</p>
<h2 id="使用UDP、TCP穿透NAT"><a href="#使用UDP、TCP穿透NAT" class="headerlink" title="使用UDP、TCP穿透NAT"></a>使用UDP、TCP穿透NAT</h2><p>上面讲的情况可以直接应用于UDP穿透技术中，使用TCP 协议穿透NAT 的方式和使用UDP 协议穿透NAT 的方式几乎一样，没有什么本质上的区别，只是将无连接的UDP 变成了面向连接的TCP 。值得注意是：</p>
<p>B在向A打洞时，发送的SYN 数据包，而且同样会被NAT_A 丢弃。同时，B需要在原来的socket 上监听，由于重用socket ，所以需要将socket 属性设置为SO_REUSEADDR。<br>A向B发送连接请求。同样，由于B到A方向的孔已经打好，所以连接会成功，经过3 次握手后，A到B之间的连接就建立起来了。具体过程如下：</p>
<ol>
<li>S启动两个网络侦听，一个叫【主连接】侦听，一个叫【协助打洞】的侦听。</li>
<li> A和B分别与S的【主连接】保持联系。</li>
<li> 当A需要和B建立直接的TCP连接时，首先连接S的【协助打洞】端口，并发送协助连接申请。同时在该端口号上启动侦听。注意由于要在相同的网络终端上绑定到不同的套接字上，所以必须为这些套接字设置 SO_REUSEADDR 属性（即允许重用），否则侦听会失败。</li>
<li>S的【协助打洞】连接收到A的申请后通过【主连接】通知B，并将A经过NAT-A转换后的公网IP地址和端口等信息告诉B。</li>
<li>B收到S的连接通知后首先与S的【协助打洞】端口连接，随便发送一些数据后立即断开，这样做的目的是让S能知道B经过NAT-B转换后的公网IP和端口号。</li>
<li>B尝试与A的经过NAT-A转换后的公网IP地址和端口进行connect，大多数路由器对于不请自到的SYN请求包直接丢弃而导致connect失败，但NAT-B会纪录此次连接的源地址和端口号，为接下来真正的连 接做好了准备，这就是所谓的打洞，即B向A打了一个洞，下次A就能直接连接到B刚才使用的端口号了。</li>
<li>客户端B打洞的同时在相同的端口上启动侦听。B在一切准备就绪以后通过与S的【主连接】回复消息“我已经准备好”，S在收到以后将B经过NAT-B转换后的公网IP和端口号告诉给A。</li>
<li>A收到S回复的B的公网IP和端口号等信息以后，开始连接到B公网IP和端口号，由于在步骤6中B曾经尝试连接过A的公网IP地址和端口，NAT-B纪录了此次连接的信息，所以当A主动连接B时，NAT-B会认为是合法的SYN数据，并允许通过，从而直接的TCP连接建立起来了。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>NAT</category>
        <category>udp</category>
      </categories>
      <tags>
        <tag>RakNet</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL编程入门： 1.Ubuntu下开发环境搭建</title>
    <url>/2017/09/02/OpenGL%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%9A-1-Ubuntu%E4%B8%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="计算机图形学与OpenGL"><a href="#计算机图形学与OpenGL" class="headerlink" title="计算机图形学与OpenGL"></a>计算机图形学与OpenGL</h1><p><a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/279486?fr=aladdin">计算机图形学</a>主要研究如何在计算机中显示丰富多彩的二维和三维图形。受益于计算机图形学的发展和图形硬件性能的飞速提升，各种游戏大作的绚丽画面令人瞠目结舌。而近两年<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/207123?fr=aladdin">虚拟现实(VR)</a>和<a href="https://baike.baidu.com/item/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E/1889025">增强现实(AR)</a>的兴起，配合着早已到来的移动互联网时代，更是让人们看到了计算机图形学所带来的未来科技的魅力。</p>
<p>在图形学编程中，计算机图形学是基础，其背后的数学原理指导我们如何将三维物体空间投射到二维屏幕空间并展现出真实的空间感。有了理论基础，我们就需要某种方法，将这种理论转化为切实的计算机程序，将画面加以呈现。这个过程中，程序员需要某种方式，可以和计算机的图形显卡进行通信，将显示数据送入显存，并告知显卡这些数据的含义，最终由显卡进行渲染，最终呈现出画面。</p>
<span id="more"></span>

<p>OpenGL正是基于这种目的所创建。它提供了一组标准的接口，用于沟通显卡，使得我们可以传送数据到显存并指定传入数据的格式。高版本OpenGL提供的可编程管线赋予了程序员对渲染流程的控制能力，以便绘制更复杂的画面和提供对渲染过程的更强的控制能力。</p>
<p>OpenGL被认为是一种底层图形API编程接口，它支持所有的主流操作系统平台。它的一个简化版本OpenGL ES被广泛应用于Android系统中，是移动互联网时代图形处理的核心解决方案，<br>当然，相较于竞争对手DirectX，OpenGL也许在易用性，效率等方面受到很多诟病，但它依然是我们接触和学习计算机图形学最好的切入点。</p>
<h1 id="关于beginners苦苦搜寻的’OpenGL-SDK’的一点说明"><a href="#关于beginners苦苦搜寻的’OpenGL-SDK’的一点说明" class="headerlink" title="关于beginners苦苦搜寻的’OpenGL SDK’的一点说明"></a>关于beginners苦苦搜寻的’OpenGL SDK’的一点说明</h1><p>程序员对于SDK的概念都是耳熟能详的。隔壁DirectX就有微软爸爸提供的SDK啊，下载安装，按照guide开始搞就好了。所以对于OpenGL，很多新手的第一反应是：<strong>去哪下SDK</strong>？</p>
<p>这里有一个’<strong>非常不幸</strong>‘的消息告诉大家： OpenGL没有SDK，官方不提供任何的二进制开发包。</p>
<p>至于这个问题的原因，在于OpenGL是一个底层图形库，它的<em>底层</em>体现在它提供对显卡的操作性。OpenGL的功能是独立于操作系统之外的，它的图形功能本身依赖于显卡而不是操作系统。这一点上，OpenGL和我们熟知的图形UI库，比如MFC，QT，又或者Java Swing ，C#等有本质的不同。</p>
<p>OpenGL可以说是一套标准，这套标准描述了OpenGL所提供的API接口集合，而对它的具体实现，则由显卡厂商来完成。也就是说，你找不到所谓的“OpenGL支持库”，也不存在SDK。它的功能直接实现在Nvidia或者ATI显卡驱动中。显卡厂商会在自家的显卡上实现OpenGL的某个特定版本并以官方驱动的形式提供给用户下载。对于普通用户来说，只需要安装新版的显卡驱动即可，无需安装其他任何东西。这也是为什么游戏玩家经常需要安装DirectX9C什么的，却很少见到有“安装OpenGL”这个说法，对于OpenGL游戏黑屏之类的问题，你要做的是升级显卡驱动。</p>
<h1 id="OpenGL开发三件套：-GLEW，GLFW，GLM"><a href="#OpenGL开发三件套：-GLEW，GLFW，GLM" class="headerlink" title="OpenGL开发三件套： GLEW，GLFW，GLM"></a>OpenGL开发三件套： GLEW，GLFW，GLM</h1><p>OpenGL的开发环境其实配置起来是要花点精力的。问题就在于，如何获取OpenGL的编程接口。因为我们有的，只是驱动厂商提供的二进制驱动程序，并没有任何的依赖库，或者头文件。那么开发工作怎么开始呢？</p>
<p>常规的做法是，从厂商的显卡驱动程序中手动获取OpenGL的导出函数地址。这是一个很繁琐的工作，我们需要手动获取到常用的OpenGL函数的函数地址，并声明为正确的函数指针格式。对于不同的显卡设备和显卡驱动版本，所支持的OpenGL版本各不相同，有些API可能在旧版本驱动中并未提供。另外一个导致这个问题复杂化的原因是OpenGL扩展。不同的厂商可能针对标准OpenGL有自己的扩展函数提供。这些函数并不包含在标准的OpenGL中，通常用来提供一些显卡相关的高级特性或者用来针对特定显卡提供效率优化。对于这部分扩展函数的处理是非常重复，繁琐和复杂的劳动。</p>
<p>所以我们有了<a href="http://glew.sourceforge.net/">GLEW</a>库，全称是“The OpenGL Extension Wrangler Library”,专门用来处理OpenGL扩展。我们只需要调用一个glewInit函数，便可以自动获取当前显卡所支持的所有扩展。</p>
<p>对比DirectX，其实OpenGL提供的功能要简单的多，它只提供了对图形的处理功能，并没有提供和窗口创建，鼠标键盘输入处理等相关的功能。所以我们需要一个跨平台的窗口类库实现以配合OpenGL实现跨平台图形程序的编写。<a href="http://www.glfw.org/">GLFW</a>正是这样一个类库，它为OpenGL/OpenGL ES/Vulkan提供了跨平台的统一接口，用以实现基本窗口创建和输入处理。</p>
<p>在开发过程中，我们会涉及一些矩阵转换，投影，缩放等数学内容，所以我们需要一个数学库来简化这些操作。<a href="https://github.com/g-truc/glm">GLM</a>可以用来解决这问题,它提供了一个和GLSL相似的语法用来处理OpenGL中常见的数学运算。</p>
<p>在ubuntu系统中，我们可以使用如下命令安装这三个依赖库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y libglew-dev libglfw3-dev libglm-dev</span><br></pre></td></tr></table></figure>


<h1 id="构建工具链和IDE的选择"><a href="#构建工具链和IDE的选择" class="headerlink" title="构建工具链和IDE的选择"></a>构建工具链和IDE的选择</h1><p>对于Linux系统上的**现代C++**项目来说，CMake永远是构建工具最有力的竞争者之一。关于CMake的具体语法和它解决了什么问题，各位看官感兴趣的可以去百度。但是CMake确实很优秀，语法简洁明了，跨平台，支持不同的编译器。<br>对于IDE的选择，qt creator和CLion都不错。它们都支持cmake工程，提供完善的语法提示和IDE调试功能。</p>
<p>个人更倾向于CLion，毕竟是付费产品，它提供的功能更完备：语法补全，错误提示，头文件自动引入等等，带给你的是一个足够爽快的编程体验。当然，作为idea系列的产品，它依赖于java，而且相对资源占用较多。在我的系统上，它还有一很影响使用体验的小bug：导航快捷键不管用。每次都要去菜单上点真的很烦。除此之外，一切都很完美。</p>
<h1 id="一个简单的示例程序"><a href="#一个简单的示例程序" class="headerlink" title="一个简单的示例程序"></a>一个简单的示例程序</h1><p>下面是一个简单的例子程序，用来显示一个彩色立方体。</p>
<figure class="highlight cpp"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glShader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glShader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glTexture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the struct to hold all values we have used.</span></span><br><span class="line"><span class="comment">// just use glfwSetWindowUserPointer to bind it to the GLFWwindow pointer.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">window_info</span>&#123;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    std::string title;</span><br><span class="line">    GLuint vertexArrayId;</span><br><span class="line">    GLuint vertexbuffer;            <span class="comment">//identify for vertex buffer</span></span><br><span class="line">    GLuint uvbuffer;                <span class="comment">//identify for uv buffer</span></span><br><span class="line">    GLuint programId;               <span class="comment">//the shader program identify we used</span></span><br><span class="line">    GLint matrixId;                 <span class="comment">//matrix location</span></span><br><span class="line">    glm::mat4 mvpMatrix;            <span class="comment">//Model-View-Projection matrix that we need translate to shader</span></span><br><span class="line">    GLuint texture;                 <span class="comment">//texture we have loaded, Sampler2D</span></span><br><span class="line">    GLuint textureId;               <span class="comment">//texture location</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initFunc</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    window_info *info = <span class="built_in">static_cast</span>&lt;window_info*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    <span class="keyword">if</span>(!info)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;initFunc: get info failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our vertices. Tree consecutive floats give a 3D vertex; Three consecutive vertices give a triangle.</span></span><br><span class="line">    <span class="comment">// A cube has 6 faces with 2 triangles each, so this makes 6*2=12 triangles, and 12*3 vertices</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> GLfloat g_vertex_buffer_data[] = &#123;</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Two UV coordinatesfor each vertex. They were created with Blender.</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> GLfloat g_uv_buffer_data[] = &#123;</span><br><span class="line">            <span class="number">0.000059f</span>, <span class="number">1.0f</span><span class="number">-0.000004f</span>,</span><br><span class="line">            <span class="number">0.000103f</span>, <span class="number">1.0f</span><span class="number">-0.336048f</span>,</span><br><span class="line">            <span class="number">0.335973f</span>, <span class="number">1.0f</span><span class="number">-0.335903f</span>,</span><br><span class="line">            <span class="number">1.000023f</span>, <span class="number">1.0f</span><span class="number">-0.000013f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span>,</span><br><span class="line">            <span class="number">0.999958f</span>, <span class="number">1.0f</span><span class="number">-0.336064f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span>,</span><br><span class="line">            <span class="number">0.336024f</span>, <span class="number">1.0f</span><span class="number">-0.671877f</span>,</span><br><span class="line">            <span class="number">0.667969f</span>, <span class="number">1.0f</span><span class="number">-0.671889f</span>,</span><br><span class="line">            <span class="number">1.000023f</span>, <span class="number">1.0f</span><span class="number">-0.000013f</span>,</span><br><span class="line">            <span class="number">0.668104f</span>, <span class="number">1.0f</span><span class="number">-0.000013f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span>,</span><br><span class="line">            <span class="number">0.000059f</span>, <span class="number">1.0f</span><span class="number">-0.000004f</span>,</span><br><span class="line">            <span class="number">0.335973f</span>, <span class="number">1.0f</span><span class="number">-0.335903f</span>,</span><br><span class="line">            <span class="number">0.336098f</span>, <span class="number">1.0f</span><span class="number">-0.000071f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span>,</span><br><span class="line">            <span class="number">0.335973f</span>, <span class="number">1.0f</span><span class="number">-0.335903f</span>,</span><br><span class="line">            <span class="number">0.336024f</span>, <span class="number">1.0f</span><span class="number">-0.671877f</span>,</span><br><span class="line">            <span class="number">1.000004f</span>, <span class="number">1.0f</span><span class="number">-0.671847f</span>,</span><br><span class="line">            <span class="number">0.999958f</span>, <span class="number">1.0f</span><span class="number">-0.336064f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span>,</span><br><span class="line">            <span class="number">0.668104f</span>, <span class="number">1.0f</span><span class="number">-0.000013f</span>,</span><br><span class="line">            <span class="number">0.335973f</span>, <span class="number">1.0f</span><span class="number">-0.335903f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span>,</span><br><span class="line">            <span class="number">0.335973f</span>, <span class="number">1.0f</span><span class="number">-0.335903f</span>,</span><br><span class="line">            <span class="number">0.668104f</span>, <span class="number">1.0f</span><span class="number">-0.000013f</span>,</span><br><span class="line">            <span class="number">0.336098f</span>, <span class="number">1.0f</span><span class="number">-0.000071f</span>,</span><br><span class="line">            <span class="number">0.000103f</span>, <span class="number">1.0f</span><span class="number">-0.336048f</span>,</span><br><span class="line">            <span class="number">0.000004f</span>, <span class="number">1.0f</span><span class="number">-0.671870f</span>,</span><br><span class="line">            <span class="number">0.336024f</span>, <span class="number">1.0f</span><span class="number">-0.671877f</span>,</span><br><span class="line">            <span class="number">0.000103f</span>, <span class="number">1.0f</span><span class="number">-0.336048f</span>,</span><br><span class="line">            <span class="number">0.336024f</span>, <span class="number">1.0f</span><span class="number">-0.671877f</span>,</span><br><span class="line">            <span class="number">0.335973f</span>, <span class="number">1.0f</span><span class="number">-0.335903f</span>,</span><br><span class="line">            <span class="number">0.667969f</span>, <span class="number">1.0f</span><span class="number">-0.671889f</span>,</span><br><span class="line">            <span class="number">1.000004f</span>, <span class="number">1.0f</span><span class="number">-0.671847f</span>,</span><br><span class="line">            <span class="number">0.667979f</span>, <span class="number">1.0f</span><span class="number">-0.335851f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//load dds texture</span></span><br><span class="line">    info-&gt;texture = <span class="built_in">loadDDS</span>(<span class="string">&quot;../resources/textures/uvtemplate.DDS&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;texture: &quot;</span> &lt;&lt; info-&gt;texture &lt;&lt; std::endl;</span><br><span class="line">    info-&gt;textureId = <span class="built_in">glGetUniformLocation</span>(info-&gt;programId,<span class="string">&quot;myTextureSampler&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;textureId: &quot;</span> &lt;&lt; info-&gt;textureId &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>,&amp;info-&gt;vertexArrayId);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(info-&gt;vertexArrayId);</span><br><span class="line">    <span class="comment">//gen buffer</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;info-&gt;vertexbuffer); <span class="comment">//gen 1 buffer,saved in vertexbuffer</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, info-&gt;vertexbuffer);    <span class="comment">//bind the generated buffer, otherwise the following operation will take effect on it.</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(</span><br><span class="line">            <span class="number">0</span>,<span class="comment">//same as the bind location</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">//size of the array element, just 3 float makes a point.</span></span><br><span class="line">            GL_FLOAT,<span class="comment">//we use float for point</span></span><br><span class="line">            GL_FALSE,<span class="comment">//not normalize</span></span><br><span class="line">            <span class="number">0</span>,<span class="comment">//stride</span></span><br><span class="line">            (<span class="type">void</span>*)<span class="number">0</span><span class="comment">//array buffer offset.</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;info-&gt;uvbuffer);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, info-&gt;uvbuffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(g_uv_buffer_data), g_uv_buffer_data, GL_STATIC_DRAW);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            GL_FLOAT,</span><br><span class="line">            GL_FALSE,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (<span class="type">void</span>*)<span class="number">0</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    info-&gt;programId = Misc::<span class="built_in">loadShader</span>(<span class="string">&quot;../resources/shaders/TexturedClubVertex.glsl&quot;</span>,<span class="string">&quot;../resources/shaders/TexturedClubFrag.glsl&quot;</span>);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LESS);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(info-&gt;programId);</span><br><span class="line">    <span class="comment">//let&#x27;s create the MVP matrix!</span></span><br><span class="line">    glm::mat4 projectionMartrix = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>),(<span class="type">float</span>)info-&gt;width / (<span class="type">float</span>)info-&gt;height,<span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="comment">//    glm::mat4 projectionMartrix = glm::ortho(-10.0f,10.0f,-10.0f,10.0f,0.0f,100.0f); // In world coordinates</span></span><br><span class="line">    glm::mat4 viewMatrix = glm::<span class="built_in">lookAt</span>(</span><br><span class="line">            glm::<span class="built_in">vec3</span>(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>),</span><br><span class="line">            glm::<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">            glm::<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    glm::mat4 modelMatrix = glm::<span class="built_in">mat4</span>( <span class="number">1.0f</span>);</span><br><span class="line">    <span class="comment">//wtf? clion give the wrong warning...</span></span><br><span class="line">    info-&gt;mvpMatrix = projectionMartrix * viewMatrix * modelMatrix;</span><br><span class="line">    info-&gt;matrixId = <span class="built_in">glGetUniformLocation</span>(info-&gt;programId, <span class="string">&quot;MVP&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initFunc success !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFunc</span><span class="params">(GLFWwindow *window)</span></span>&#123;</span><br><span class="line">    window_info* info = <span class="built_in">static_cast</span>&lt;window_info*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    <span class="keyword">if</span>(!info)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;drawFunc: get info failed !&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetWindowSize</span>(window, &amp;info-&gt;width, &amp;info-&gt;height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>,<span class="number">0</span>,info-&gt;width,info-&gt;height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(info-&gt;programId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(info-&gt;matrixId, <span class="number">1</span>, GL_FALSE, &amp;info-&gt;mvpMatrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//I don&#x27;t understand it now.</span></span><br><span class="line">    <span class="comment">//how to relate texture and it&#x27;s location?</span></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, info-&gt;texture);</span><br><span class="line">    <span class="built_in">glUniform1i</span>(info-&gt;textureId, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(info-&gt;matrixId, <span class="number">1</span>, GL_FALSE, &amp;info-&gt;mvpMatrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(info-&gt;vertexArrayId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES,<span class="number">0</span>, <span class="number">12</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanFunc</span><span class="params">(GLFWwindow *window)</span></span>&#123;</span><br><span class="line">    window_info *info = <span class="built_in">static_cast</span>&lt;window_info*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    <span class="keyword">if</span>(!info)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cleanFun: get info failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glDisableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>,&amp;info-&gt;vertexbuffer);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;info-&gt;uvbuffer);</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>,&amp;info-&gt;vertexArrayId);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(info-&gt;programId);</span><br><span class="line">    <span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;info-&gt;texture);</span><br><span class="line">    <span class="comment">//delete info</span></span><br><span class="line">    <span class="built_in">glfwSetWindowUserPointer</span>(window, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">delete</span> info;</span><br><span class="line">    <span class="comment">//destory window</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cleanFunc success !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetErrorCallback</span>([](<span class="type">int</span> errorCode, <span class="type">const</span> <span class="type">char</span>* errorMsg)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; errorCode &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; errorMsg &lt;&lt;  std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;glfwInit failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    window_info *info = <span class="keyword">new</span> window_info;</span><br><span class="line">    info-&gt;width = <span class="number">800</span>;</span><br><span class="line">    info-&gt;height = <span class="number">600</span>;</span><br><span class="line">    info-&gt;title = <span class="string">&quot;ogl-toturial-texture-clube&quot;</span>;</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(info-&gt;width,info-&gt;height,info-&gt;title.<span class="built_in">c_str</span>(),<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)&#123;</span><br><span class="line">        <span class="keyword">delete</span> info;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;glfwCreateWindow failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwSetWindowUserPointer</span>(window,info);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    glewExperimental = GL_TRUE;</span><br><span class="line">    <span class="keyword">if</span>(GLEW_OK != <span class="built_in">glewInit</span>())&#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;glewInit failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">initFunc</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//绘制</span></span><br><span class="line">        <span class="built_in">drawFunc</span>(window);</span><br><span class="line">        <span class="comment">//swap buffer</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清理</span></span><br><span class="line">    <span class="built_in">cleanFunc</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight glsl"><figcaption><span>TexturedClubVertex.glsl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexPosition_modelspace;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> vertexUV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> UV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> MVP;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = MVP * <span class="type">vec4</span>(vertexPosition_modelspace, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  UV = vertexUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight glsl"><figcaption><span>TexturedClubFrag.glsl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> UV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> myTextureSampler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Output color = color of the texture at the specific UV</span></span><br><span class="line">  color = <span class="built_in">texture</span>(myTextureSampler, UV).rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机图形学</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>OpenGL编程入门</tag>
      </tags>
  </entry>
  <entry>
    <title>RakNet入门介绍</title>
    <url>/2016/09/07/RakNet%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="RakNet简单介绍"><a href="#RakNet简单介绍" class="headerlink" title="RakNet简单介绍"></a>RakNet简单介绍</h1><p>最近由于项目需要简单看了一下RakNet。<br>这是一个C++开发的基于UDP的开源网络库，具有良好的跨平台特性，主要用于网络游戏的通信，也可以用在各种网络软件上用于处理网络通信。</p>
<p>总体来说这个库功能完善，提供可靠的UDP传输，完善的插件机制。项目托管在<a href="https://github.com/OculusVR/RakNet">github</a>目前已停止更新。关于它的具体用法，可以参考官网的例子和文档。</p>
<span id="more"></span>

<p>按照网上的说法 RakNet大概有如下特点：</p>
<blockquote>
<p>Radnet有以下特点：</p>
</blockquote>
<blockquote>
<pre><code>  高性能         在同一台计算机上，Radnet可以实现在两个程序之间每秒传输25，000条信息；
</code></pre>
</blockquote>
<blockquote>
<pre><code>  容易使用       Radnet有在线用户手册，视频教程。每一个函数和类都有详细的讲解，每一个功能都有自己的例程；
</code></pre>
</blockquote>
<blockquote>
<pre><code>  跨平台         当前Radnet支持Windows, Linux, Macs，可以建立在Visual Studio, GCC, Code: Blocks, DevCPP 和其它平台上；
</code></pre>
</blockquote>
<blockquote>
<pre><code>  在线技术支持   RakNet有一个活跃的论坛，邮件列表，你只要给他们发信，他们可以在几小时之内回复你。
</code></pre>
</blockquote>
<blockquote>
<pre><code>  安全的传输     RakNet在你的代码中自动使用SHA1, AES128, SYN，用RSA避免传输受到攻击
</code></pre>
</blockquote>
<blockquote>
<pre><code>  音频传输       用Speex编码解码，8位的音频只需要每秒500字节传输。
</code></pre>
</blockquote>
<blockquote>
<pre><code>  远程终端       用RakNet，你能远程管理你的程序，包括程序的设置，密码的管理和日志的管理。
</code></pre>
</blockquote>
<blockquote>
<pre><code>  目录服务器     目录服务器允许服务器列举他们自己需要的客户端，并与他们连接。
</code></pre>
</blockquote>
<blockquote>
<pre><code>  Autopatcher   Autopatcher系统将限制客户端传输到服务端的文件，这样是为了避免一些不合法的用户将一些不合法的文件传输到服务端。
</code></pre>
</blockquote>
<blockquote>
<pre><code>  对象重载系统
</code></pre>
</blockquote>
<blockquote>
<pre><code>  网络数据压缩   BitStream类允许压缩矢量，矩阵，四元数和在-1到1之间的实数。
</code></pre>
</blockquote>
<blockquote>
<pre><code>  远程功能调用
</code></pre>
</blockquote>
<blockquote>
<pre><code>  强健的通信层   可以保障信息按照不同的信道传输
</code></pre>
</blockquote>
<p>而且网上说这个东西的文档和例子丰富，然而百度了一圈发现，除了官网的例子，RakNet的其他例子很少。像我这样暂时只要一个UDP可靠通信的人来说，就有点不太友好了。百度知道上关于RakNet词条中的例子肯定不是4.x版本的，根本就不能用。<br>经过一番百度+测试，终于自己搞定了一个简单的例子，代码贴上来做个备忘。</p>
<p>VS2015的测试工程，新建控制台工程，把github上clone的src目录的源码全部添加到工程，然后加上如下的测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;../RakNet/src/RakPeerInterface.h&quot;</span><br><span class="line">#include &quot;../RakNet/src/RakNetTypes.h&quot;</span><br><span class="line">#include &quot;../RakNet/src/MessageIdentifiers.h&quot;</span><br><span class="line">#include &quot;../RakNet/src/BitStream.h&quot;</span><br><span class="line">#include &quot;../RakNet/src/RakString.h&quot;</span><br><span class="line">#include &quot;../RakNet/src/StringCompressor.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int StartServer();</span><br><span class="line">int StartClient(void* param);</span><br><span class="line"></span><br><span class="line">//测试下RakNet</span><br><span class="line">void main(int argc, char* argv[]) &#123;</span><br><span class="line">	PTHREAD pThread = 0;</span><br><span class="line">	RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();</span><br><span class="line">	if (!peer)</span><br><span class="line">	&#123;</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;main get peer failed.&quot;);</span><br><span class="line">		system(&quot;pause&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	LogUtils::i(LOG_TAG, &quot;（C）客服端 (S)服务器?&quot;);</span><br><span class="line">	char str = getchar();</span><br><span class="line">	if (str == &#x27;c&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		StartClient(NULL);</span><br><span class="line">		//PlatformAbstract::CreateThread(pThread, (THREADPROCTYPE)&amp;StartClient, NULL);</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;::main 客服端已经建立。&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		StartServer();</span><br><span class="line">		//PlatformAbstract::CreateThread(pThread, (THREADPROCTYPE)&amp;StartServer, NULL);</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;::main 服务器已经建立。&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">////这里是一个测试方法 可以直接放到测试工程中测试</span><br><span class="line">int StartServer() &#123;</span><br><span class="line">	//给服务器端创建一个实例  </span><br><span class="line">	RakNet::RakPeerInterface* pPeer = RakNet::RakPeerInterface::GetInstance();</span><br><span class="line">	if (NULL == pPeer)</span><br><span class="line">	&#123;</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;TestFunc get pPeer failed.&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;::TestFunc ---------MyChatServer Init Success(C)-----------&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RakNet::Packet* pPacket;</span><br><span class="line">	LogUtils::i(LOG_TAG, &quot;::TestFunc Start Server .....&quot;);</span><br><span class="line">	//启动服务器  </span><br><span class="line">	RakNet::SocketDescriptor sd = RakNet::SocketDescriptor(6000, 0);</span><br><span class="line">	RakAssert(RakNet::RAKNET_STARTED == pPeer-&gt;Startup(1, &amp;sd, 1));</span><br><span class="line">	//设置最大链接数  </span><br><span class="line">	pPeer-&gt;SetMaximumIncomingConnections(1);</span><br><span class="line">	auto boundAddress = pPeer-&gt;GetMyBoundAddress();</span><br><span class="line">	const char* sAddr = boundAddress.ToString();</span><br><span class="line">	LogUtils::e(LOG_TAG, &quot;::StartServer sAddr: %s&quot;, sAddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//////////////////////////////////////////////////////////////////////////  </span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (pPacket = pPeer-&gt;Receive(); pPacket; pPeer-&gt;DeallocatePacket(pPacket), pPacket = pPeer-&gt;Receive())</span><br><span class="line">		&#123;</span><br><span class="line">			LogUtils::e(LOG_TAG, &quot;StartServer pPacket type: %d&quot;, pPacket-&gt;data[0]);</span><br><span class="line">			switch (pPacket-&gt;data[0])</span><br><span class="line">			&#123;</span><br><span class="line">			case ID_REMOTE_DISCONNECTION_NOTIFICATION: &#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer Another client has disconnected&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line">			case ID_REMOTE_CONNECTION_LOST: &#123;</span><br><span class="line">				LogUtils::i(LOG_TAG, &quot;StartServer ID_REMOTE_CONNECTION_LOST&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line">			case ID_REMOTE_NEW_INCOMING_CONNECTION: &#123;</span><br><span class="line">				LogUtils::i(LOG_TAG, &quot;StartServer ID_REMOTE_CONNECTION_LOST&quot;);</span><br><span class="line">				RakNet::BitStream bs;</span><br><span class="line">				bs.Write &lt; RakNet::MessageID&gt;(ServerConnectBack);</span><br><span class="line">				RakNet::StringCompressor::Instance()-&gt;EncodeString(pPacket-&gt;systemAddress.ToString(true), 255, &amp;bs);</span><br><span class="line"></span><br><span class="line">			&#125;break;</span><br><span class="line">				//client端调用Connect后收到的server响应</span><br><span class="line">			case ID_CONNECTION_REQUEST_ACCEPTED: &#123;</span><br><span class="line">				LogUtils::i(LOG_TAG, &quot;StartServer ID_CONNECTION_REQUEST_ACCEPTED&quot;);</span><br><span class="line"></span><br><span class="line">				RakNet::BitStream bsOut;</span><br><span class="line">				bsOut.Write((RakNet::MessageID)ID_USER_PACKET_ENUM + 1);</span><br><span class="line">				bsOut.Write(&quot;Server Say Hello.&quot;);</span><br><span class="line">				pPeer-&gt;Send(&amp;bsOut, HIGH_PRIORITY, UNRELIABLE_SEQUENCED, 0, pPeer-&gt;GetMyBoundAddress(), false);</span><br><span class="line">			&#125;break;</span><br><span class="line">				//server端收到来自client的Connect</span><br><span class="line">			case ID_NEW_INCOMING_CONNECTION: &#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer ID_NEW_INCOMING_CONNECTION&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line">			case ID_NO_FREE_INCOMING_CONNECTIONS: &#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer ID_NO_FREE_INCOMING_CONNECTIONS&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line">			case ID_DISCONNECTION_NOTIFICATION: &#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer ID_DISCONNECTION_NOTIFICATION&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line">			case ID_CONNECTION_LOST: &#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer ID_CONNECTION_LOST&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line">			case ID_CONNECTION_ATTEMPT_FAILED: &#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer ID_CONNECTION_ATTEMPT_FAILED&quot;);</span><br><span class="line">			&#125;break;</span><br><span class="line"></span><br><span class="line">				//用户自定义数据包  </span><br><span class="line">			case ID_USER_PACKET_ENUM + 1:</span><br><span class="line">			&#123;</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;StartServer recv ID_USER_PACKET_ENUM + 1: %d&quot;, ID_USER_PACKET_ENUM + 1);</span><br><span class="line">				RakNet::RakString rs1, rs2;</span><br><span class="line">				RakNet::BitStream bsIn(pPacket-&gt;data, pPacket-&gt;length, false);</span><br><span class="line">				bsIn.IgnoreBytes(sizeof(RakNet::MessageID));</span><br><span class="line">				//bsIn.Read(rs);  //提取字符串           </span><br><span class="line">				RakNet::StringCompressor::Instance()-&gt;DecodeString(&amp;rs1, 255, &amp;bsIn);</span><br><span class="line">				RakNet::StringCompressor::Instance()-&gt;DecodeString(&amp;rs2, 255, &amp;bsIn);</span><br><span class="line">				LogUtils::e(LOG_TAG, &quot;::StartServer Recv User Data: %s %s %s&quot;, pPacket-&gt;systemAddress.ToString(true, &#x27;|&#x27;), rs1.C_String(), rs2.C_String());</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">			default: &#123;</span><br><span class="line">				LogUtils::i(LOG_TAG, &quot;::TestFunc Message with identifier %i has arrived&quot;, pPacket-&gt;data[0]);</span><br><span class="line">			&#125;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//////////////////////////////////////////////////////////////////////////  </span><br><span class="line">	RakNet::RakPeerInterface::DestroyInstance(pPeer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StartClient(void* param) &#123;</span><br><span class="line">	//获取RakNetPeer接口</span><br><span class="line">	RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();</span><br><span class="line">	if (!peer)</span><br><span class="line">	&#123;</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;::StartClient get peer failed.&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	RakNet::SocketDescriptor  sd = RakNet::SocketDescriptor(0, 0);</span><br><span class="line">	RakAssert(RakNet::RAKNET_STARTED == peer-&gt;Startup(1, &amp;sd, 1));</span><br><span class="line">	LogUtils::i(LOG_TAG, &quot;::StartClient get peer success&quot;);</span><br><span class="line">	RakAssert(RakNet::CONNECTION_ATTEMPT_STARTED == peer-&gt;Connect(&quot;127.0.0.1&quot;, 6000, 0, 0, 0, 0));</span><br><span class="line">	while (peer-&gt;IsActive())</span><br><span class="line">	&#123;</span><br><span class="line">		//开始发包了</span><br><span class="line">		LogUtils::i(LOG_TAG, &quot;::StartClient %d 发包&quot;, GetTickCount());</span><br><span class="line"></span><br><span class="line">		RakNet::BitStream bIn;</span><br><span class="line">		bIn.Write&lt;RakNet::MessageID&gt;(ID_USER_PACKET_ENUM + 1);</span><br><span class="line">		RakNet::StringCompressor::Instance()-&gt;EncodeString(&quot;Client Say Hello&quot;, 255, &amp;bIn);</span><br><span class="line">		RakNet::StringCompressor::Instance()-&gt;EncodeString(&quot;Client Say NMH&quot;, 255, &amp;bIn);</span><br><span class="line">		//注意broadcast参数 如果是true，则发广播，systemidentifier表示不发送地址，一般使用常量 RakNet::UNASSIGNED_SYSTEM_ADDRESS</span><br><span class="line">		//					如果是false，则往systemidentifier指定的ip和端口处发送</span><br><span class="line">		//					如果发包是有序的，则channel指定了信道，同一信道的具有递增的排序值，避免有多种有序消息的排序值相互干扰</span><br><span class="line">		uint32_t sendrs = peer-&gt;Send(&amp;bIn, HIGH_PRIORITY, UNRELIABLE_SEQUENCED, 0, RakNet::SystemAddress(&quot;127.0.0.1&quot;, 6000), false);</span><br><span class="line">		LogUtils::e(LOG_TAG, &quot;StartClient sendres: %d&quot;, sendrs);</span><br><span class="line">		Sleep(1000);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	peer-&gt;Shutdown(1000);</span><br><span class="line">	RakNet::RakPeerInterface::DestroyInstance(peer);</span><br><span class="line">	peer = NULL;</span><br><span class="line">	LogUtils::e(LOG_TAG, &quot;Disconnect from Server. StartClient peer closed&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于Android，我们可以把RakNet编译成静态库，然后链接到我们的so库中使用，</p>
<p>Android.mk内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := RakNet</span><br><span class="line">LOCAL_MODULE_FILENAME := libRakNet</span><br><span class="line"></span><br><span class="line">APP_ABI := armeabi armeabi-v7a </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 遍历目录及子目录的函数</span><br><span class="line">define walk</span><br><span class="line">$(wildcard $(1)) $(foreach e, $(wildcard $(1)/*), $(call walk, $(e)))</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"># 按目录引用</span><br><span class="line">FILE_LIST := $(filter %.cpp, $(call walk, $(LOCAL_PATH)/src))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这里注意做一次重复条目过滤 call uniq 不然重复条目会报很多错误</span><br><span class="line">LOCAL_SRC_FILES := $(call uniq,$(FILE_LIST:$(LOCAL_PATH)/%=%))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(BUILD_STATIC_LIBRARY)</span><br></pre></td></tr></table></figure>

<p>Application.mk内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APP_STL := gnustl_static</span><br><span class="line">APP_CPPFLAGS += -fexceptions</span><br><span class="line">APP_ABI :=armeabi armeabi-v7a</span><br><span class="line">APP_PLATFORM := android-19</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术文档</category>
        <category>socket</category>
        <category>udp</category>
      </categories>
      <tags>
        <tag>RakNet</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记 开篇</title>
    <url>/2017/04/13/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="关于本系列文章"><a href="#关于本系列文章" class="headerlink" title="关于本系列文章"></a>关于本系列文章</h1><p>本系列文章是我个人学习UE4游戏制作过程中一些随笔性质的记录性文章。因为我个人并不属于游戏行业但是对于自己动手做游戏又充满了兴趣，所以花了些时间了解了下一些游戏制作相关的内容。可能点点滴滴的东西都比较初级而且浅显，但是我会仔细地去记录自己学习的过程，希望也对后来者能够有所启发，这样也就达到了目的。</p>
<p>我个人也比较懒散，我也希望能够用分享知识的方式督促自己能够不断地学习。可日进一步，吾心足矣。</p>
<span id="more"></span>

<h1 id="关于游戏引擎的选择"><a href="#关于游戏引擎的选择" class="headerlink" title="关于游戏引擎的选择"></a>关于游戏引擎的选择</h1><p>对于游戏开发来说，引擎是我们最好的朋友。</p>
<p>游戏领域相对于软件行业的其它领域，面对着更多的挑战。现代大型游戏有着复杂的逻辑，丰富的玩法，绚丽的画面。这些元素的堆叠导致了游戏程序本身有着很高复杂度的同时还要求有高性能，能够以稳定的帧率运行。这对程序员来说，是一个艰巨的挑战。除此之外，游戏还拥有大量的美术资产，各种模型的导入与管理，策划的奇思妙想需要实现，数值平衡和玩法改动导致的频繁修改，大量复杂bug修复等等。</p>
<p>所以业内有识之士很快发现，每次从头开始写一个游戏是一个吃力不讨好的行为，在现代游戏规模越来越大的情况下，这种每次都从头开始的行为甚至是无法接受的。</p>
<p>所以游戏引擎这种提供游戏开发基础设施和游戏制作流程中完整工作流的重量级软件应运而生。长久以来，专用引擎一向是大公司的专利，作为小公司或者独立制作人，选择一款逞心如意的引擎成为了我们跨入游戏开发的第一步。</p>
<p>对于市面上常见的游戏引擎，大概有如下几个：cocos2d unity UE4 CryEngine。<br>其中cocos2d是2d引擎，剩下的3个都是3d引擎。然后在后三者中，unity目前主要用于移动游戏开发，单机游戏中也有一部分选择此引擎，比如残念的仙剑6。UE和CE则是一对老冤家。</p>
<p>就效果上来说，unity3d也许是一时之选：支持多平台，完善的工作流，3D和2D都有良好表现，是独立游戏和小团队首选引擎。</p>
<p>我个人也了解过一点unity3d，尝试过用它做款游戏出来，但是却因为个人原因没能坚持下去。也许不得不说，我是个喜新厌旧的人。我个人不太喜欢unity3d的到处挂脚本的开发方式。再到后来，我接触到了UE4,它的复杂度比之unity3d要高很多，到处透露着一种“高大上”的气息。也许是学习曲线过于陡峭，在上手学过一阵子之后，感觉仍然不得要领。</p>
<p>但是最后还是想选定UE4进行深入学习。UE4本身也有一个强大的社区和大量的官方文档，对于上手学习来说，并不存在什么障碍。希望自己能在不久的将来使用UE4开发出自己心目中的理想的游戏，也希望自己能通过UE4找到下一个饭碗。</p>
<h1 id="关于UE4的学习路线"><a href="#关于UE4的学习路线" class="headerlink" title="关于UE4的学习路线"></a>关于UE4的学习路线</h1><p>我个人是C++程序员，对我来说UE4的C++果然像官方介绍一样“妙不可言”。对于程序出身的开发者，我个人的学习路线如下：</p>
<blockquote>
<p>UE编辑器基础-&gt;蓝图基本使用-&gt;C++基础部分-&gt;地形和模型导入系统-&gt;材质编辑器的基本使用-&gt;官方示例的几个样板工程学习</p>
</blockquote>
<p>对于UE4引擎本身，我想说，它不愧为久负盛名的3A引擎，其强大的功能和完善的工作流是创建3A游戏的强力保证。</p>
<p>后续的文章，我会带来一些我自己学习过程中的一些体悟，请大家拭目以待。</p>
]]></content>
      <categories>
        <category>UE4学习笔记</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>git简介-程序员的后悔药</title>
    <url>/2017/06/11/git%E7%AE%80%E4%BB%8B-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF/</url>
    <content><![CDATA[<h1 id="从软件开发谈“后悔药”的必要性"><a href="#从软件开发谈“后悔药”的必要性" class="headerlink" title="从软件开发谈“后悔药”的必要性"></a>从软件开发谈“后悔药”的必要性</h1><p>每当我们作出一个决定，我们就必然要承担它带来的后果。很多时候，面对未来的不确定性，我们会作出错误的决定。这时我们往往追悔莫及。但是这个世界上却永远不存在“后悔药”。就目前的科技水平来看，我们无力操纵时空，篡改历史。</p>
<p>万幸的是，作为程序员，我们却有工具来在软件开发的过程中随时给自己安利一发“后悔药”尝尝咸淡。这种后悔药叫做“版本控制”。</p>
<span id="more"></span>

<p>自计算机发明以来，IT这个行业乘着web，移动互联网的东风，开始了高速的发展：各种技术，框架，解决方案层出不穷。随着计算机的性能越来越强，人们有了越来越大的野心，希望借助计算机完成更多的工作，服务于现实生活。这种野望带来了软件规模的急剧膨胀。程序员面对这越来越复杂的情況，开始进入了大规模的协作开发阶段。这时候摆在人们面前的问题有很多，比如：</p>
<ol>
<li>怎样才能顺利的协作？我改的函数别人也改过，怎么才能把大家的修改合并在一起？</li>
<li>某个版本出现问题，如何能够方便地进行版本回滚以挽救自己的饭碗？</li>
<li>代码写到一半的时候老大通知线上的bug需要紧急修复，自己这里写到一半的代码还跑不起来，how to play?</li>
<li>我们发布了1.0版本，然后发布了2.0版本，测试发现2.0版本存在某个bug而1.0版本却没有，怎么才能快速排查并定位问题？</li>
</ol>
<p>这些情况都要求我们能够有效地管理程序的各种版本，形成一个可以回溯的版本历史记录，以便我们可以通过对版本历史的回溯操作来达到自如切换的目的。</p>
<p>也许你听说过svn，但是我们今天要介绍的却是版本控制工具里的”大杀器”: git</p>
<p>git被证明是目前版本控制工具里的最佳实践。它的设计者是大名鼎鼎的顶级黑客<strong>linus torvalds</strong>，linux内核的原作者，linux开源社区的领导者。linus以一个文件系统设计者的思维高度设计了分布式版本控制工具git，其先进的设计理念让这个工具迅速风靡，可以说拯救了无数程序员的饭碗。</p>
<p>正所谓前人栽树后人乘凉，在此感谢linus大神间接地赏了口饭吃。</p>
<h1 id="git的一些基本概念"><a href="#git的一些基本概念" class="headerlink" title="git的一些基本概念"></a>git的一些基本概念</h1><p>总体上来说，git是有一些复杂的，暂存区，分支，HEAD指针，rebase,merge，一下会有很多的概念。<br>首先，git的一个特性就是，它管理的是“修改”本身，而是文件。git保存了文件的一个基础版本并维护了针对该文件的所有修改，而不是为文件的每个历史版本做一个记录。这也似git速度快的一个主要原因。</p>
<p>unix是有diff和patch工具的，同样，linux也有。早些年的linux开发中，linus就是使用这两个工具来手动合并代码修改的。估计是长期手动合并代码的后遗症，linus设计git的时候就引入了这两个备受他信赖的工具，作为git的基础。git就是一整套构建于diff，patch，hash-1基础之上的“修改历史”数据库，我们通过git命令操作这个数据库，来方便地管理我们的程序版本。git上各种眼花缭乱的操作，branch，rebase，merge等等，都和git的这种底层设计密不可分。</p>
<p>关于git的叙述，可以写出几本书，对于有志于系统地学习git使用的同学，简爱那一阅读这些书以获得系统的知识。本文只git的一个简单介绍。个人认为，用过svn的人对git最大的不理解来自于git的 “add commit”的提交方式。每个文件必须通过add添加到版本库，然后使用commit提交。很多git的新手会产生这样的疑惑：为什么要把提交分成两步？这个设计的背后其实涉及到git的一组核心概念:</p>
<p><strong>工作区，暂存区 ，版本库</strong></p>
<img src="/2017/06/11/git%E7%AE%80%E4%BB%8B-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF/06/11/git%E7%AE%80%E4%BB%8B-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF/git-stage.png" class title="git存储区">

<p>从上图可以看到，左侧为工作区，右侧版本库中，标记index的是暂存区，标记为master的则是master分支所包含的目录树。objects则是git的对象，它包含我们对文件的修改，文件目录，commit提交信息，tags等信息，它才是git中实际存储的内容。git使用索引的方式将git对象组织起来，最终呈现给我们的就是一个具体的代码版本。</p>
<p>git中，git的数据库位于我们执行git init的根目录中，是一个名为.git的隐藏文件夹。工作区就是我们进行编码工作的地方，它位于版本库之外。当我们执行git add添加了某个文件之后，git就会把我们针对该文件的修改生成objects对象，这样这个修改就进入了暂存区。暂存区的内容还没有被有效地组织起来，所以我们使用git status，git仍然会提示这些文件，它们的状态被标记为added。理解了这个概念，现在想想，为什么当我们添加了大量的新文件的时候，git会卡？因为git忙着为每个被添加的文件执行diff，比较差异并生成相应的对象存放到暂存区。当我们执行commit提交之后，git会生成一个commit对象来引用我们所有的修改以此来将修改从暂存区真正地提交到版本库中。这个提交同时持有它的父提交的hash-1值。这样提交就可以被正确地索引，我们的提交历史也会被正确地组织起来。</p>
<p>大致有这个印象之后，我们就可以立即一些git操作背后的魔法，比如git checkout仅仅是从git版本库中提取指定文件的指定版本覆盖到工作区。git branch也仅仅是添加一个branch指针指向了某个固定的commit等等。</p>
<p>git的一切“魔法”都基于git的这种组织机构来实现。</p>
<p>git是linus为自己设计的用以管理linux内核的工具。它是久经考验的，它分布式的管理方式和方便的分支切换工作流程，强大的多分支合并和历史回溯功能特别适合于大规模的协作开发。git的威力在linux内核代码管理上得到了充分的验证。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>这篇的内容不算很长，我们还没有讲过git的一些基础操作，就这样草草结束好像不是太好。不过也也没关系，git说到底还是一个工具，一个提高程序员生产力并在必要时候保护他们脆弱饭碗的方式。对于工具的学习，更多时候是靠着不断的使用来巩固和提高的。</p>
<p>如果你在实际项目中使用git并且你的开发团队能够正确地使用它，相信你很快就能学会git的使用并惊叹于它的灵活和强大。如果有机会，我想我们会在后续讨论一些git的使用技巧。git中的一些看似神奇的高端操作，正式它有别于其它版本控制工具的关键。掌握了它们，才不会让git明珠蒙尘。</p>
<p>看着项目组其它人熟练地使用git命令行来操作git，真的惊叹于git命令行的神奇，其作为一个命令行管理工具，自有其道理。git命令行相比于GUI工具，有着更大的灵活性和便利性，值得每个希望深入使用git的开发人员认真学习。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>quickjs调试机制实现解析</title>
    <url>/2021/09/17/quickjs%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="对调试器的最初印象"><a href="#对调试器的最初印象" class="headerlink" title="对调试器的最初印象"></a>对调试器的最初印象</h1><p>每个刚入行的程序员都有过对调试器一知半解的时候，那时我们使用 <strong>printf</strong>，<strong>console.log</strong>, <strong>System.out.println</strong> 等进行错误定位，统称<strong>打印输出调试法</strong>，这个方法至今在服务器后端等无法停机更无法挂调试器的地方大行其道，我们叫它<strong>log日志</strong>。<br>当我们工作了一段时间之后，逐渐发现了编程世界的复杂性，有些问题无法通过简单的打印来定位：</p>
<ol>
<li>程序内某个变量的值被改掉了，我想知道是哪里改的</li>
<li>两个相同的组件，一个表现正常一个不正常，why?</li>
<li>程序存在死锁或其他多线程静态条件，怎么定位和修复？</li>
<li>我的程序内存泄露了，怎么办</li>
</ol>
<p>上面列举的一些情况有些可以借助debugger，有些如内存泄露，还需要借助其他的分析工具，但不可否认的是，debugger是程序员修bug奋斗之路上最坚实的后盾。代码出了问题，你能依靠的只有你自己的逻辑和你手里的调试工具。哦，当然，你也可以选择摇人，这个不在本文讨论范围之内。</p>
<p>我们都会用到debugger，它一般提供如下功能：</p>
<ol>
<li>控制程序运行，如断点，单步执行等</li>
<li>查看，修改变量值</li>
<li>修改程序执行流程</li>
</ol>
<p>调试功能我们常用，但就是因为它太常用了，是语言附属的基础设施，所以我们好像很少会去思考，它是如何实现的？</p>
<span id="more"></span>

<h1 id="调试器是怎么实现的"><a href="#调试器是怎么实现的" class="headerlink" title="调试器是怎么实现的"></a>调试器是怎么实现的</h1><p>在聊JS调试器之前，我们先聊一聊关于调试器更通用的一些东西，理解软件调试技术在实现层面的一些思路和细节。</p>
<h2 id="调试器的架构"><a href="#调试器的架构" class="headerlink" title="调试器的架构"></a>调试器的架构</h2><p>传统的调试器实现，一般分为调试器前端（Fortended）和调试器后端（Backend）。前端用于展示，后端实现调试功能。这种架构很经典，后端专注于调试功能实现，前端专注于展示界面，前后端之间使用IPC(包括但不限于命名管道，socket，共享内存，内存文件等)进行通信。</p>
<h2 id="VSCode和DAP协议"><a href="#VSCode和DAP协议" class="headerlink" title="VSCode和DAP协议"></a>VSCode和DAP协议</h2><p>在VSCode出现之前，一个单纯的editor是很难和调试器进行整合的，面临如下困难：</p>
<ol>
<li>需要支持多个调试器，传统的editor如vim，emacs等难以提供统一的调试界面。</li>
<li>不同的调试后端之间并没有提供统一的接口，对接不通语言的调试器或者统一语言的不通调试器实现工作量巨大</li>
<li>不同的调试器功能并不完全一致，没办法统一去实现，前端的实现和特定后端绑定</li>
</ol>
<p>软件行业有一条“<strong>金科玉律</strong>“：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</p>
<div align="right">————佚名</div>
</blockquote>
<p>为了克服上述困难，为不同语言的调试器提供统一支持，微软给出了这个“<strong><strong>中间层</strong></strong>“，推出了<a href="https://microsoft.github.io/debug-adapter-protocol/specification">DAP协议</a>。<br>DAP是基于JSON实现的通信协议，对调试功能进行了消息通信层面的标准化，VSCode作为调试器的通用前端，开发者可以专注于实现后端。后端要做的就是接收JSON request，执行功能，发送JSON reply。</p>
<p><strong>调试功能传统实现和DAP协议之后的标准实现对比：</strong><br><img src="/2021/09/17/quickjs%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/IMG_2021-09-22-15-06-58.png" alt="未使用DAP协议时调试功能的实现"><br><img src="/2021/09/17/quickjs%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/IMG_2021-09-18-10-57-34.png" alt="DAP协议下调试器的实现"></p>
<p>软件行业的杀手锏就是<strong><strong>分层</strong></strong>和<strong><strong>标准化</strong></strong>，两者往往相辅相成：一旦某个部分被标准化，它往往会成为一个独立的协议和接口层。当某个东西标准化并被接受成为事实标准，一切就变得简单起来了。标准化是通用的基础，这种东西业内俗称“<strong><strong>轮子</strong></strong>”，可以极大地降低功能开发的复杂度。</p>
<p>DAP协议和VSCode调试界面，不在本文的讨论范围之内。对调试器前端实现感兴趣的同学可以参考<a href="https://github.com/microsoft/vscode-mock-debug">vscode-mock-debug</a>，它给出了一个调试器前端的mock实现。<br>本文中我们主要聊调试器后端的实现。</p>
<h2 id="调试器后端实现"><a href="#调试器后端实现" class="headerlink" title="调试器后端实现"></a>调试器后端实现</h2><p>接下来我们重点聊一聊调试器后端要实现的主要功能和实现思路。</p>
<h3 id="如何暂停"><a href="#如何暂停" class="headerlink" title="如何暂停"></a>如何暂停</h3><p>debugger的一个核心功能便是要让程序能够在特定的情况下中断执行（命中断点），然后让用户控制程序一步一步往下跑，以观察执行过程中程序具体行为，每一步操作是否符合预期。所以这里<strong>暂停执行</strong>是关键。<br>所以，谁才有能力暂停一个程序的执行呢？如果你使用的是C/C++/Rust/go这种可以编译到汇编的语言，进程，线程等机制是由操作系统实现的，进程和线程的调度也是由系统实现，所以操作系统理应有能力<strong>暂停</strong>一个程序的执行。所以聪明的你可能想到了，对于这类程序，调试功能是由<strong>操作系统</strong>提供的，具体来说是操作系统的<strong>调试子系统</strong>。这类语言的调试器直接依赖于操作系统提供的调试API来实现（linux上一般是gdb/lldb）。<br>我们按照这个思路递推，如果是js呢？谁有能力暂停一个js程序的执行？理所应当是js引擎。所以对于js语言，调试功能应该在<strong>js引擎</strong>层予以支持和实现。</p>
<h3 id="如何在源码层面命中断点和单步执行"><a href="#如何在源码层面命中断点和单步执行" class="headerlink" title="如何在源码层面命中断点和单步执行"></a>如何在源码层面命中断点和单步执行</h3><p>我们把这两个放在一起说，因为它们具有一定的相似性，都是要完成从源码到字节码的转换。</p>
<p>语言的编译是一个翻译过程，一般用于将一种高级的，表达能力强的语言，翻译成一种低级的，表达能力弱的语言或者是生成对应的字节码。</p>
<blockquote>
<p>对于C/C++语言，编译后生成的是二进制程序，它直接对应于机器汇编，由cpu直接执行。<br>对于js语言，编译后生成js字节码，由js引擎解释执行。</p>
</blockquote>
<p>一般来说，一句C或者js代码经过编译后会生成多条汇编指令或者字节码指令。这是由<strong>信息密度</strong>决定的，高级语言的信息密度比汇编/字节码要高（这也是为什么我们不直接写汇编/字节码，而是搞了个编译器去生成它），所以翻译后会带来操作（汇编指令/字节码指令）数量的膨胀。当我们实现调试器的时候，我们要面临的首要问题就是：</p>
<blockquote>
<p>如何将字节码/汇编代码与JS/C++源码进行对应？</p>
</blockquote>
<p>解决方案是什么？其实并不复杂，我们需要一个映射关系，用来告诉debugger，字节码执行到这里，应该对应到源码的哪个文件的哪一行，用户单步执行一次，需要执行几个字节码指令。断点的设置也是一样，我们需要知道用户在某个文件的某一行设置的断点到底应该对应到汇编/字节码的哪个指令上。<br>（有没有同学想到js里的source map?思路是一样的）<br>命中断点则是在每次执行时，检查当前的程序计数器PC是否执行到了我们设置断点的地方，即可得知是否命中断点，如果命中断点则中断程序的执行（对C++,暂停其所在线程的执行，对JS，不再继续解释下一条指令）。<br>这个映射关系在C++里被称作调试符号，windows上vs会单独生成这个文件后缀名是.pdb（Programing Database），linux上gcc选择将调试符号直接嵌入到二进制文件中，可以通过strip命令去除。<br>在js里，好像并不单独存在这样一个文件，因为js编译生成的字节码一般情况下并不会被保存在硬盘上，quickjs中，调试信息被保存在了编译生成的字节码中。</p>
<h3 id="如何查看和修改变量的值"><a href="#如何查看和修改变量的值" class="headerlink" title="如何查看和修改变量的值"></a>如何查看和修改变量的值</h3><p>debugger接管了程序的执行过程，在程序暂停时，是可以获取和修改变量值的。<br>对于JS来说，变量都是通过C结构体模拟的，其中包含有变量的类型信息，变量查看和修改比较好实现。我们可以通过js context获取到所有的全局变量和局部变量的值，对它们的修改自然也不在话下。<br>对于C++这种编译型语言，由于编译时丢失了类型信息，查看和修改变量值的过程比较麻烦，需要对内存进行转换，我们不再展开。</p>
<h1 id="怎么实现一个js-debugger"><a href="#怎么实现一个js-debugger" class="headerlink" title="怎么实现一个js debugger"></a>怎么实现一个js debugger</h1><p>聊了这么久，我们终于开到了喜闻乐见的<strong>show me the code</strong>环节。在这里我们解析quickjs中针对调试功能的具体实现，我们主要关注整体流程，忽略无关且繁杂枝节，以期对实现原理有个大概的印象。</p>
<h2 id="quickjs调试功能实现"><a href="#quickjs调试功能实现" class="headerlink" title="quickjs调试功能实现"></a>quickjs调试功能实现</h2><p>现在我们会结合<a href="https://github.com/koush/quickjs">quickjs源码</a>来大致浏览一下quickjs中调试功能的实现方式。quickjs本身是不支持调试的，现在使用的调试功能是第三方的开源实现，整体实现思路相当的简单粗暴。</p>
<h3 id="JS函数功能执行入口"><a href="#JS函数功能执行入口" class="headerlink" title="JS函数功能执行入口"></a>JS函数功能执行入口</h3><p>此函数是JS字节码解释的核心函数，极长，有<strong>2543行</strong>之巨，处理了方方面面的情况，整体是一个超级巨大的switch，根据字节码的opcode进行解释执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JSValue <span class="title function_">JS_CallInternal</span><span class="params">(JSContext *caller_ctx, JSValueConst func_obj,</span></span><br><span class="line"><span class="params">                               JSValueConst this_obj, JSValueConst new_target,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> argc, JSValue *argv, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必要的检测和初始化</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义CASE宏，执行每个字节码分支的时候，都会执行js_debugger_check以执行调试检测</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE(op)        case_debugger_ ## op: js_debugger_check(ctx, pc); case_ ## op</span></span><br><span class="line">    </span><br><span class="line"> restart:</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> call_argc;</span><br><span class="line">        JSValue *call_argv;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调试检测函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AIOTJS_ENABLE_SIM_DEBUG</span></span><br><span class="line">        js_debugger_check(ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据opcode进行dispatch处理</span></span><br><span class="line">        SWITCH(pc) &#123;</span><br><span class="line">        CASE(OP_push_i32):</span><br><span class="line">            *sp++ = JS_NewInt32(ctx, get_u32(pc));</span><br><span class="line">            pc += <span class="number">4</span>;</span><br><span class="line">            BREAK;</span><br><span class="line">        CASE(OP_push_const):</span><br><span class="line">            *sp++ = JS_DupValue(ctx, b-&gt;cpool[get_u32(pc)]);</span><br><span class="line">            pc += <span class="number">4</span>;</span><br><span class="line">            BREAK;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHORT_OPCODES</span></span><br><span class="line">        CASE(OP_push_minus1):</span><br><span class="line">        CASE(OP_push_0):</span><br><span class="line">        CASE(OP_push_1):</span><br><span class="line">        CASE(OP_push_2):</span><br><span class="line">        CASE(OP_push_3):</span><br><span class="line">        CASE(OP_push_4):</span><br><span class="line">        CASE(OP_push_5):</span><br><span class="line">        CASE(OP_push_6):</span><br><span class="line">        CASE(OP_push_7):</span><br><span class="line">            *sp++ = JS_NewInt32(ctx, opcode - OP_push_0);</span><br><span class="line">            BREAK;</span><br><span class="line">        CASE(OP_push_i8):</span><br><span class="line">            *sp++ = JS_NewInt32(ctx, get_i8(pc));</span><br><span class="line">            pc += <span class="number">1</span>;</span><br><span class="line">            BREAK;</span><br><span class="line">        CASE(OP_push_i16):</span><br><span class="line">            *sp++ = JS_NewInt32(ctx, get_i16(pc));</span><br><span class="line">            pc += <span class="number">2</span>;</span><br><span class="line">            BREAK;</span><br><span class="line">        CASE(OP_push_const8):</span><br><span class="line">            *sp++ = JS_DupValue(ctx, b-&gt;cpool[*pc++]);</span><br><span class="line">            BREAK;</span><br><span class="line">        CASE(OP_fclosure8):</span><br><span class="line">            *sp++ = js_closure(ctx, JS_DupValue(ctx, b-&gt;cpool[*pc++]), var_refs, sf);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(JS_IsException(sp[<span class="number">-1</span>])))</span><br><span class="line">                <span class="keyword">goto</span> exception;</span><br><span class="line">            BREAK;</span><br><span class="line">        CASE(OP_push_empty_string):</span><br><span class="line">            *sp++ = JS_AtomToString(ctx, JS_ATOM_empty_string);</span><br><span class="line">            BREAK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line"> exception:</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理及返回</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试功能入口"><a href="#调试功能入口" class="headerlink" title="调试功能入口"></a>调试功能入口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">js_debugger_check</span><span class="params">(JSContext* ctx, <span class="type">const</span> <span class="type">uint8_t</span> *cur_pc)</span> &#123;</span><br><span class="line">    <span class="comment">//调用js_debugger_check之前需要设置通知函数</span></span><br><span class="line">    JSDebuggerInfo *info = js_debugger_info(JS_GetRuntime(ctx));</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;is_debugging)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;debugging_ctx == ctx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    info-&gt;is_debugging = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// info-&gt;ctx = ctx;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据两个特定的环境变量来连接调试器</span></span><br><span class="line">    <span class="keyword">if</span> (!info-&gt;attempted_connect) &#123;</span><br><span class="line">        info-&gt;attempted_connect = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> *address = getenv(<span class="string">&quot;QUICKJS_DEBUG_ADDRESS&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (address != <span class="literal">NULL</span> &amp;&amp; !info-&gt;transport_close)</span><br><span class="line">            <span class="comment">//前端先启动，后端直接连接，无阻塞，无法连接则报错</span></span><br><span class="line">            js_debugger_connect(ctx, address, g_debugger_attach_notify);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!info-&gt;attempted_wait) &#123;</span><br><span class="line">        info-&gt;attempted_wait = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> *address = getenv(<span class="string">&quot;QUICKJS_DEBUG_LISTEN_ADDRESS&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (address != <span class="literal">NULL</span> &amp;&amp; !info-&gt;transport_close)</span><br><span class="line">            <span class="comment">//后端阻塞直到连接到前端</span></span><br><span class="line">            js_debugger_wait_connection(ctx, address, g_debugger_attach_notify);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;transport_close == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">JSDebuggerLocation</span> <span class="title">location</span>;</span></span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已暂停，单步执行中，检测location和depth</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;stepping) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (已到达step位置)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测是否命中断点</span></span><br><span class="line">    <span class="type">int</span> at_breakpoint = js_debugger_check_breakpoint(ctx, info-&gt;breakpoints_dirty_counter, cur_pc);</span><br><span class="line">    <span class="keyword">if</span> (at_breakpoint) &#123;</span><br><span class="line">        <span class="comment">// 命中已存在的断点，向vscode发送暂停消息，暂停原因为 breakpoint</span></span><br><span class="line">        info-&gt;stepping = <span class="number">0</span>;</span><br><span class="line">        info-&gt;is_paused = <span class="number">1</span>;</span><br><span class="line">        js_send_stopped_event(info, <span class="string">&quot;breakpoint&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;stepping) &#123;</span><br><span class="line">        <span class="comment">//单步执行 continue</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;stepping == JS_DEBUGGER_STEP_CONTINUE) &#123;</span><br><span class="line">            info-&gt;stepping = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;stepping == JS_DEBUGGER_STEP_IN) &#123;</span><br><span class="line">            <span class="comment">//单步执行 step in</span></span><br><span class="line">            <span class="type">int</span> depth = js_debugger_stack_depth(ctx);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (info-&gt;step_depth == depth) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">JSDebuggerLocation</span> <span class="title">location</span> =</span> js_debugger_current_location(ctx, cur_pc);</span><br><span class="line">                <span class="keyword">if</span> (location.filename == info-&gt;step_over.filename</span><br><span class="line">                    &amp;&amp; location.line == info-&gt;step_over.line</span><br><span class="line">                    &amp;&amp; location.column == info-&gt;step_over.column)</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            info-&gt;stepping = <span class="number">0</span>;</span><br><span class="line">            info-&gt;is_paused = <span class="number">1</span>;</span><br><span class="line">            js_send_stopped_event(info, <span class="string">&quot;stepIn&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;stepping == JS_DEBUGGER_STEP_OUT) &#123;</span><br><span class="line">            <span class="comment">//单步执行 step out</span></span><br><span class="line">            <span class="type">int</span> depth = js_debugger_stack_depth(ctx);</span><br><span class="line">            <span class="keyword">if</span> (depth &gt;= info-&gt;step_depth)</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            info-&gt;stepping = <span class="number">0</span>;</span><br><span class="line">            info-&gt;is_paused = <span class="number">1</span>;</span><br><span class="line">            js_send_stopped_event(info, <span class="string">&quot;stepOut&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;stepping == JS_DEBUGGER_STEP) &#123;</span><br><span class="line">            <span class="comment">//单步执行 step</span></span><br><span class="line">            <span class="keyword">struct</span> JSDebuggerLocation location = js_debugger_current_location(ctx, cur_pc);</span><br><span class="line">            <span class="comment">// to step over, need to make sure the location changes,</span></span><br><span class="line">            <span class="comment">// and that the location change isn&#x27;t into a function call (deeper stack).</span></span><br><span class="line">            <span class="keyword">if</span> (已到达step位置)</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            info-&gt;stepping = <span class="number">0</span>;</span><br><span class="line">            info-&gt;is_paused = <span class="number">1</span>;</span><br><span class="line">            js_send_stopped_event(info, <span class="string">&quot;step&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ???</span></span><br><span class="line">            info-&gt;stepping = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并处理调试消息，主要是从前端发送的命令请求，入断点，查询变量值等</span></span><br><span class="line">    <span class="comment">//内部调用了js_process_debugger_messages</span></span><br><span class="line">    <span class="type">int</span> ret = js_debugger_process_server_message(ctx);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    <span class="comment">//前端调试命令处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (js_process_debugger_messages(info, cur_pc))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    fail: </span><br><span class="line">        js_debugger_free(JS_GetRuntime(ctx), info);</span><br><span class="line">    done:</span><br><span class="line">        info-&gt;is_debugging = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// info-&gt;ctx = NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试命令处理"><a href="#调试命令处理" class="headerlink" title="调试命令处理"></a>调试命令处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">js_process_debugger_messages</span><span class="params">(JSDebuggerInfo *info, <span class="type">const</span> <span class="type">uint8_t</span> *cur_pc)</span> &#123;</span><br><span class="line">    <span class="comment">// continue processing messages until the continue message is received.</span></span><br><span class="line">    JSContext *ctx = info-&gt;ctx;</span><br><span class="line">    <span class="keyword">if</span>(ctx == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DebuggerSuspendedState</span> <span class="title">state</span>;</span></span><br><span class="line">    state.variable_reference_count = js_debugger_stack_depth(ctx) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    state.variable_pointers = JS_NewObject(ctx);</span><br><span class="line">    state.variable_references = JS_NewObject(ctx);</span><br><span class="line">    state.cur_pc = cur_pc;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> message_length_buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//检测和分配buffer缓冲区</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从socket中读取前端发来的json命令</span></span><br><span class="line">        <span class="keyword">if</span> (!js_transport_read_fully(info, info-&gt;message_buffer, message_length))</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        </span><br><span class="line">        info-&gt;message_buffer[message_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JSON.parse转换成js json对象</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析请求类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;request&quot;</span>, type) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//request请求</span></span><br><span class="line">            js_process_request(info, &amp;state, JS_GetPropertyStr(ctx, message, <span class="string">&quot;request&quot;</span>));</span><br><span class="line">            <span class="comment">// done_processing = 1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;continue&quot;</span>, type) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//继续执行</span></span><br><span class="line">            info-&gt;is_paused = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;breakpoints&quot;</span>, type) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//处理断点消息</span></span><br><span class="line">            js_process_breakpoints(info, JS_GetPropertyStr(ctx, message, <span class="string">&quot;breakpoints&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;stopOnException&quot;</span>, type) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//处理异常暂停</span></span><br><span class="line">            JSValue stop = JS_GetPropertyStr(ctx, message, <span class="string">&quot;stopOnException&quot;</span>);</span><br><span class="line">            info-&gt;exception_breakpoint = JS_ToBool(ctx, stop);</span><br><span class="line">            JS_FreeValue(ctx, stop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理临时js对象</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (info-&gt;is_paused);</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//清理临时js对象</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quickjs调试功能小结"><a href="#quickjs调试功能小结" class="headerlink" title="quickjs调试功能小结"></a>quickjs调试功能小结</h3><p>此处我们不再继续向里展开，再聊下去无非是实现层面的一些细节，考虑到我们这里大部分都是前端开发者，对C代码的实现细节我们不再做进一步的阐述。<br>本文主旨在阐述调试器实现原理和给出一个内容梗概，相较于扣细节，我更喜欢讲原理，因为细节必定依赖于特定语言而原理是一些更通用的解题思路，思路打开了，很多东西也就迎刃而解了。<br>下面我们对调试流程做个补充和总结：</p>
<ul>
<li>quickjs调试器使用server/client模式进行开发，VSCode为server，quickjs引擎为client。</li>
<li>server/client之间使用socket进行连接，通过DAP协议（JSON）进行通信。</li>
<li>每解释执行一条js字节码，都会调用<strong>js_debugger_check</strong>，尝试连接调试器，接收并处理调试消息。</li>
<li>DAP协议定义和规范了调试消息的格式，在VSCode调试界面上的操作（如下断点）最终会生成一条对应的JSON消息，通过socket发送给js引擎</li>
<li>引擎解析从server收到的json消息，根据请求类型，完成如下断点/获取变量值/单步执行等操作。</li>
<li>引擎执行完指定操作之后，会向server发送reply消息，通知sever操作已完成或报告错误，VSCode会根据返回的消息更新调试界面（单步执行后移动到下一行/将引擎中最新的变量值更新到变量窗口）</li>
</ul>
<h2 id="深入探究：quickjs断点实现原理详解"><a href="#深入探究：quickjs断点实现原理详解" class="headerlink" title="深入探究：quickjs断点实现原理详解"></a>深入探究：quickjs断点实现原理详解</h2><p>在上面的原理解析部分，我们简单聊过了如何将字节码和源码做对应，现在我们要落实到实处，看一下在quickjs中，是如何存储这个映射关系，或者叫<strong>调试信息</strong>的，又是如何正确命中断点的。<br>想要弄懂这些，需要深入到quickjs字节码生成和实现的一些细节，因为调试信息也是quickjs字节码的一部分，我们将聚焦于调试信息相关的部分带领大家做一个简单了解。这部分不可避免地要了解quickjs的C代码实现的部分细节，我们会尽量简略，省略掉不必要的细节，仅关注和断点相关的部分。<br>来，让我们一睹调试器的庐山真面目。</p>
<h3 id="js函数定义结构体"><a href="#js函数定义结构体" class="headerlink" title="js函数定义结构体"></a>js函数定义结构体</h3><p>quickjs中，js代码的编译解析是以function为最小单元的，引擎会解析js源文件，以js函数为单位生成字节码，我们先来看一个js函数在引擎中的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">JSFunctionDef</span> &#123;</span></span><br><span class="line">    JSContext *ctx;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    DynBuf byte_code;       <span class="comment">//用于保存函数对应字节码的数组</span></span><br><span class="line">    <span class="type">int</span> last_opcode_pos; <span class="comment">/* -1 if no last opcode */</span></span><br><span class="line">    <span class="type">int</span> last_opcode_line_num;</span><br><span class="line">    BOOL use_short_opcodes; <span class="comment">/* true if short opcodes are used in byte_code */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保存标签符号</span></span><br><span class="line">    LabelSlot *label_slots;</span><br><span class="line">    <span class="type">int</span> label_size; <span class="comment">/* allocated size for label_slots[] */</span></span><br><span class="line">    <span class="type">int</span> label_count;</span><br><span class="line">    BlockEnv *top_break; <span class="comment">/* break/continue label stack */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存行号</span></span><br><span class="line">    LineNumberSlot *line_number_slots;</span><br><span class="line">    <span class="type">int</span> line_number_size;</span><br><span class="line">    <span class="type">int</span> line_number_count;</span><br><span class="line">    <span class="type">int</span> line_number_last;</span><br><span class="line">    <span class="type">int</span> line_number_last_pc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pc2line table */</span></span><br><span class="line">    JSAtom filename;</span><br><span class="line">    <span class="type">int</span> line_num;</span><br><span class="line">    DynBuf pc2line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应源码片段</span></span><br><span class="line">    <span class="type">char</span> *source;  <span class="comment">/* raw source, utf-8 encoded */</span></span><br><span class="line">    <span class="type">int</span> source_len;</span><br><span class="line"></span><br><span class="line">    JSModuleDef *module; <span class="comment">/* != NULL when parsing a module */</span></span><br><span class="line">&#125; JSFunctionDef;</span><br></pre></td></tr></table></figure>
<p>上面的定义省略了和调试无关的部分，可以看到函数结构体中保存了函数中的标签符号信息，行号信息，pc2line(字节码到行号)映射信息，源码片段等。</p>
<h3 id="eval时解析js源码"><a href="#eval时解析js源码" class="headerlink" title="eval时解析js源码"></a>eval时解析js源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,</span><br><span class="line">                                 <span class="type">const</span> <span class="type">char</span> *input, <span class="type">size_t</span> input_len,</span><br><span class="line">                                 <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags, <span class="type">int</span> scope_idx)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化parser，跳过注释</span></span><br><span class="line">    js_parse_init(ctx, s, input, input_len, filename);</span><br><span class="line">    skip_shebang(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理各种flag</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建函数定义结构，即 JSFunctionDef的实例</span></span><br><span class="line">    fd = js_new_function_def(ctx, <span class="literal">NULL</span>, TRUE, FALSE, filename, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">        <span class="keyword">goto</span> fail1;</span><br><span class="line">    <span class="comment">//对fd进行赋值</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用JSParseState结构解析源码</span></span><br><span class="line">    err = js_parse_program(s);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    fail:</span><br><span class="line">        free_token(s, &amp;s-&gt;token);</span><br><span class="line">        js_free_function_def(ctx, fd);</span><br><span class="line">        <span class="keyword">goto</span> fail1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建函数</span></span><br><span class="line">    <span class="comment">/* create the function object and all the enclosed functions */</span></span><br><span class="line">    fun_obj = js_create_function(ctx, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误检测和处理</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> JS_EXCEPTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成字节码时保存行号信息"><a href="#生成字节码时保存行号信息" class="headerlink" title="生成字节码时保存行号信息"></a>生成字节码时保存行号信息</h3><p><strong>js_parse_program</strong>是字节码生成的主体函数，通过一个JSParseState结构体对js进行语法解析并生成字节码，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __exception <span class="type">int</span> <span class="title function_">js_parse_program</span><span class="params">(JSParseState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    JSFunctionDef *fd = s-&gt;cur_func;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_token(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (js_parse_directives(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fd-&gt;is_global_var = (fd-&gt;eval_type == JS_EVAL_TYPE_GLOBAL) ||</span><br><span class="line">        (fd-&gt;eval_type == JS_EVAL_TYPE_MODULE) ||</span><br><span class="line">        !(fd-&gt;js_mode &amp; JS_MODE_STRICT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;is_module) &#123;</span><br><span class="line">        <span class="comment">/* hidden variable for the return value */</span></span><br><span class="line">        fd-&gt;eval_ret_idx = idx = add_var(s-&gt;ctx, fd, JS_ATOM__ret_);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;token.val != TOK_EOF) &#123;</span><br><span class="line">        <span class="comment">//顺序解析直到结尾</span></span><br><span class="line">        <span class="keyword">if</span> (js_parse_source_element(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;is_module) &#123;</span><br><span class="line">        <span class="comment">/* return the value of the hidden variable eval_ret_idx  */</span></span><br><span class="line">        emit_op(s, OP_get_loc);</span><br><span class="line">        emit_u16(s, fd-&gt;eval_ret_idx);</span><br><span class="line"></span><br><span class="line">        emit_op(s, OP_return);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        emit_op(s, OP_return_undef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析的过程嵌套较深，会针对不同的语法元素调用不同的子过程函数进行解析，我们来看其中的一个函数以理解quickjs如何在生成字节码的同时保存行号信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">emit_op</span><span class="params">(JSParseState *s, <span class="type">uint8_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    JSFunctionDef *fd = s-&gt;cur_func;</span><br><span class="line">    DynBuf *bc = &amp;fd-&gt;byte_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the line number of the last token used, not the next token,</span></span><br><span class="line"><span class="comment">       nor the current offset in the source file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(fd-&gt;last_opcode_line_num != s-&gt;last_line_num)) &#123;</span><br><span class="line">        <span class="comment">//在字节码数组中保存行号信息，对应的opcode是 OP_line_num</span></span><br><span class="line">        dbuf_putc(bc, OP_line_num);</span><br><span class="line">        dbuf_put_u32(bc, s-&gt;last_line_num);</span><br><span class="line">        fd-&gt;last_opcode_line_num = s-&gt;last_line_num;</span><br><span class="line">    &#125;</span><br><span class="line">    fd-&gt;last_opcode_pos = bc-&gt;size;</span><br><span class="line">    dbuf_putc(bc, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出一个quickjs的语法分析器的工作流程，对quickjs源码感兴趣的同学可以参考系列博文<a href="https://www.zhihu.com/column/c_1337176691518140416">QuickJS剖析</a><br><img src="/2021/09/17/quickjs%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/IMG_2021-09-23-10-26-16.png"></p>
<h3 id="创建函数并保存pc2line信息"><a href="#创建函数并保存pc2line信息" class="headerlink" title="创建函数并保存pc2line信息"></a>创建函数并保存pc2line信息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JSValue <span class="title function_">js_create_function</span><span class="params">(JSContext *ctx, JSFunctionDef *fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理scop，variable，eval，module等细节</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前函数中定义的子函数，优先创建child，最后创建本体</span></span><br><span class="line">    <span class="comment">/* first create all the child functions */</span></span><br><span class="line">    list_for_each_safe(el, el1, &amp;fd-&gt;child_list) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建子函数</span></span><br><span class="line">        func_obj = js_create_function(ctx, fd1);</span><br><span class="line">        <span class="comment">//错误检测</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将子函数对象存入cpool数组</span></span><br><span class="line">        fd-&gt;cpool[cpool_idx] = func_obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析变量</span></span><br><span class="line">    <span class="keyword">if</span> (resolve_variables(ctx, fd))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="comment">//解析label符号，内部会收集并计算pc2line信息</span></span><br><span class="line">    <span class="keyword">if</span> (resolve_labels(ctx, fd))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配JSFunctionBytecode结构体</span></span><br><span class="line">    b = js_mallocz(ctx, function_size);</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    b-&gt;header.ref_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将parse时生成的字节码拷贝到JSFunctionBytecode结构中保存</span></span><br><span class="line">    b-&gt;byte_code_buf = (<span class="type">void</span> *)((<span class="type">uint8_t</span>*)b + byte_code_offset);</span><br><span class="line">    b-&gt;byte_code_len = fd-&gt;byte_code.size;</span><br><span class="line">    <span class="built_in">memcpy</span>(b-&gt;byte_code_buf, fd-&gt;byte_code.buf, fd-&gt;byte_code.size);</span><br><span class="line">    <span class="comment">//释放fd-&gt;byte_code</span></span><br><span class="line">    js_free(ctx, fd-&gt;byte_code.buf);</span><br><span class="line">    fd-&gt;byte_code.buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//保存函数名</span></span><br><span class="line">    b-&gt;func_name = fd-&gt;func_name;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd-&gt;js_mode &amp; JS_MODE_STRIP) &#123;</span><br><span class="line">        <span class="comment">//strip模式，去掉调试信息，释放pc2line结构体</span></span><br><span class="line">        JS_FreeAtom(ctx, fd-&gt;filename);</span><br><span class="line">        dbuf_free(&amp;fd-&gt;pc2line);    <span class="comment">// probably useless</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非strip模式（debug模式），提取pc2line结构体</span></span><br><span class="line">        b-&gt;has_debug = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//保存函数所在文件名</span></span><br><span class="line">        b-&gt;debug.filename = fd-&gt;filename;</span><br><span class="line">        <span class="comment">//保存函数所在行</span></span><br><span class="line">        b-&gt;debug.line_num = fd-&gt;line_num;</span><br><span class="line">        <span class="comment">//分配pc2line缓冲区</span></span><br><span class="line">        b-&gt;debug.pc2line_buf = js_realloc(ctx, fd-&gt;pc2line.buf, fd-&gt;pc2line.size);</span><br><span class="line">        <span class="comment">//将fd的pc2line.buf保存到 b-&gt;debug.pc2line_buf</span></span><br><span class="line">        <span class="keyword">if</span> (!b-&gt;debug.pc2line_buf)</span><br><span class="line">            b-&gt;debug.pc2line_buf = fd-&gt;pc2line.buf;</span><br><span class="line">        b-&gt;debug.pc2line_len = fd-&gt;pc2line.size;</span><br><span class="line">        b-&gt;debug.source = fd-&gt;source;</span><br><span class="line">        b-&gt;debug.source_len = fd-&gt;source_len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JS_EXCEPTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolve_labels函数需要重点关注，在解析label的同时，此函数中会调用<strong>add_pc2line_info</strong>函数添加行号信息到pc2line table</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __exception <span class="type">int</span> <span class="title function_">resolve_labels</span><span class="params">(JSContext *ctx, JSFunctionDef *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历JSFunctionDef中保存的字节码数组，解析每条指令</span></span><br><span class="line">    <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; bc_len; pos = pos_next) &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        op = bc_buf[pos];</span><br><span class="line">        len = opcode_info[op].size;</span><br><span class="line">        pos_next = pos + len;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> OP_line_num:</span><br><span class="line">            <span class="comment">//OP_line_num指令，读取字节码中保存的行号信息</span></span><br><span class="line">            line_num = get_u32(bc_buf + pos + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OP_label:</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OP_call:</span><br><span class="line">        <span class="keyword">case</span> OP_call_method:</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//添加pc2line_info，line_num的来源是之前字节码中保存的行号</span></span><br><span class="line">                <span class="comment">//pc的来源是遍历时的字节码数组下标</span></span><br><span class="line">                add_pc2line_info(s, bc_out.size, line_num);</span><br><span class="line">                put_short_code(&amp;bc_out, op, argc);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> no_change;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OP_return:</span><br><span class="line">        <span class="keyword">case</span> OP_return_undef:</span><br><span class="line">        <span class="keyword">case</span> OP_return_async:</span><br><span class="line">        <span class="keyword">case</span> OP_throw:</span><br><span class="line">        <span class="keyword">case</span> OP_throw_error:</span><br><span class="line">            pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &amp;line_num);</span><br><span class="line">            <span class="keyword">goto</span> no_change;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    js_free(ctx, s-&gt;label_slots);</span><br><span class="line">    s-&gt;label_slots = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//所有的pc2line信息已添加，编码计算最终的pc2line数组</span></span><br><span class="line">    compute_pc2line_info(s);</span><br><span class="line">    js_free(ctx, s-&gt;line_number_slots);</span><br><span class="line">    s-&gt;line_number_slots = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* set the new byte code */</span></span><br><span class="line">    dbuf_free(&amp;s-&gt;byte_code);</span><br><span class="line">    s-&gt;byte_code = bc_out;</span><br><span class="line">    s-&gt;use_short_opcodes = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (dbuf_error(&amp;s-&gt;byte_code)) &#123;</span><br><span class="line">        JS_ThrowOutOfMemory(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> fail:</span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> not safe */</span></span><br><span class="line">    dbuf_free(&amp;bc_out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>add_pc2line_info将pc2line信息添加到JSFunctionDef结构体的<strong>line_number_slots</strong>数组中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_pc2line_info</span><span class="params">(JSFunctionDef *s, <span class="type">uint32_t</span> pc, <span class="type">int</span> line_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;line_number_slots != <span class="literal">NULL</span></span><br><span class="line">    &amp;&amp;  s-&gt;line_number_count &lt; s-&gt;line_number_size</span><br><span class="line">    &amp;&amp;  pc &gt;= s-&gt;line_number_last_pc</span><br><span class="line">    &amp;&amp;  line_num != s-&gt;line_number_last) &#123;</span><br><span class="line">        <span class="comment">//记录当前的pc值和行号</span></span><br><span class="line">        s-&gt;line_number_slots[s-&gt;line_number_count].pc = pc;</span><br><span class="line">        s-&gt;line_number_slots[s-&gt;line_number_count].line_num = line_num;</span><br><span class="line">        s-&gt;line_number_count++;</span><br><span class="line">        s-&gt;line_number_last_pc = pc;</span><br><span class="line">        s-&gt;line_number_last = line_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolve_labels函数的最后，当所有的行号信息都添加完毕后，调用<strong>compute_pc2line_info</strong>来编码最终的pc2line信息，目的是为了节约空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">compute_pc2line_info</span><span class="params">(JSFunctionDef *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;js_mode &amp; JS_MODE_STRIP) &amp;&amp; s-&gt;line_number_slots) &#123;</span><br><span class="line">        <span class="type">int</span> last_line_num = s-&gt;line_num;</span><br><span class="line">        <span class="type">uint32_t</span> last_pc = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        js_dbuf_init(s-&gt;ctx, &amp;s-&gt;pc2line);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;line_number_count; i++) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> pc = s-&gt;line_number_slots[i].pc;</span><br><span class="line">            <span class="type">int</span> line_num = s-&gt;line_number_slots[i].line_num;</span><br><span class="line">            <span class="type">int</span> diff_pc, diff_line;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line_num &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算pc和line的差值</span></span><br><span class="line">            diff_pc = pc - last_pc;</span><br><span class="line">            diff_line = line_num - last_line_num;</span><br><span class="line">            <span class="keyword">if</span> (diff_line == <span class="number">0</span> || diff_pc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将diff_pc和diff_line编码为一个值，方式是 通过除PC2LINE_RANGE取余,举个例子</span></span><br><span class="line">            <span class="comment">//z = x * 5 + y</span></span><br><span class="line">            <span class="comment">//x = z / 5</span></span><br><span class="line">            <span class="comment">//y = z % 5</span></span><br><span class="line">            <span class="comment">//可以编码，编码以节约空间</span></span><br><span class="line">            <span class="keyword">if</span> (diff_line &gt;= PC2LINE_BASE &amp;&amp;</span><br><span class="line">                diff_line &lt; PC2LINE_BASE + PC2LINE_RANGE &amp;&amp;</span><br><span class="line">                diff_pc &lt;= PC2LINE_DIFF_PC_MAX) &#123;</span><br><span class="line">                dbuf_putc(&amp;s-&gt;pc2line, (diff_line - PC2LINE_BASE) +</span><br><span class="line">                          diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//容纳不下，将值直接存入</span></span><br><span class="line">                <span class="comment">/* longer encoding */</span></span><br><span class="line">                dbuf_putc(&amp;s-&gt;pc2line, <span class="number">0</span>);</span><br><span class="line">                dbuf_put_leb128(&amp;s-&gt;pc2line, diff_pc);</span><br><span class="line">                dbuf_put_sleb128(&amp;s-&gt;pc2line, diff_line);</span><br><span class="line">            &#125;</span><br><span class="line">            last_pc = pc;</span><br><span class="line">            last_line_num = line_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调试信息生成流程"><a href="#调试信息生成流程" class="headerlink" title="调试信息生成流程"></a>调试信息生成流程</h3><p><img src="/2021/09/17/quickjs%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/IMG_2021-09-18-19-09-56.png" alt="调试信息生成流程"></p>
<h3 id="使用pc2line信息检查是否命中断点"><a href="#使用pc2line信息检查是否命中断点" class="headerlink" title="使用pc2line信息检查是否命中断点"></a>使用pc2line信息检查是否命中断点</h3><p>引擎解释执行一条js字节码，都会调用<strong>js_debugger_check</strong>，其内部会调用<strong>js_debugger_check_breakpoint</strong>已检查是否命中断点，我们来看这个函数的实现细节：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">js_debugger_check_breakpoint</span><span class="params">(JSContext *ctx, <span class="type">uint32_t</span> current_dirty, <span class="type">const</span> <span class="type">uint8_t</span> *cur_pc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p指向了便是我们之前通过compute_pc2line_info计算出的pc2line编码信息缓冲区开头</span></span><br><span class="line">    p = b-&gt;debug.pc2line_buf;</span><br><span class="line">    <span class="comment">//p_end指向了pc2line编码信息缓冲区末尾</span></span><br><span class="line">    p_end = p + b-&gt;debug.pc2line_len;</span><br><span class="line">    pc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//line_num赋值为b-&gt;debug.line_num，这个值是函数所在行号</span></span><br><span class="line">    line_num = b-&gt;debug.line_num;</span><br><span class="line">    <span class="comment">//遍历所有的断点信息以检测它们是否命中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; breakpoints_length; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> last_line_num = line_num;</span><br><span class="line">        <span class="type">int</span> line_pc = pc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没扫到pc2line末尾且扫描行号不大于断点行号，则不断扫描</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; p_end &amp;&amp; line_num &lt;= breakpoint_line) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按行扫描，直到到达新行</span></span><br><span class="line">            <span class="keyword">while</span> (p &lt; p_end &amp;&amp; line_num == last_line_num) &#123;</span><br><span class="line">                op = *p++;</span><br><span class="line">                <span class="comment">//op是0对应着pc2line无法编码的情况，直接读取</span></span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">uint32_t</span> val;</span><br><span class="line">                    ret = get_leb128(&amp;val, p, p_end);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> fail;</span><br><span class="line">                    pc += val;</span><br><span class="line">                    p += ret;</span><br><span class="line">                    ret = get_sleb128(&amp;v, p, p_end);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> fail;</span><br><span class="line">                    p += ret;</span><br><span class="line">                    new_line_num = line_num + v;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//可以编码，从op中解码出 diff_pc和diff_line</span></span><br><span class="line">                    op -= PC2LINE_OP_FIRST;</span><br><span class="line">                    pc += (op / PC2LINE_RANGE);</span><br><span class="line">                    <span class="comment">//计算新行，使用diff_line + line_num得到</span></span><br><span class="line">                    new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;</span><br><span class="line">                &#125;</span><br><span class="line">                line_num = new_line_num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到新行，则判断它是否命中断点</span></span><br><span class="line">            <span class="keyword">if</span> (line_num != last_line_num) &#123;</span><br><span class="line">                <span class="comment">// new line found, check if it is the one with breakpoint.</span></span><br><span class="line">                <span class="keyword">if</span> (last_line_num == breakpoint_line &amp;&amp; line_num &gt; last_line_num)</span><br><span class="line">                    <span class="comment">//命中，将命中行对应的指令位置设置为1，标记它们被设置了断点</span></span><br><span class="line">                    <span class="comment">//这样做的理由是，一行的js源码可能对应多条字节码指令，所以要将一段位置都设置成1，代码运行到这个区段中都视作命中断点</span></span><br><span class="line">                    <span class="built_in">memset</span>(b-&gt;debugger.breakpoints + line_pc, <span class="number">1</span>, pc - line_pc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the line trackers</span></span><br><span class="line">                line_pc = pc;</span><br><span class="line">                last_line_num = line_num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &gt;= p_end)</span><br><span class="line">            b-&gt;debugger.last_line_num = line_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    JS_FreeValue(ctx, breakpoints);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    JS_FreeValue(ctx, path_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!b-&gt;debugger.breakpoints)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pc = (cur_pc ? cur_pc : ctx-&gt;rt-&gt;current_stack_frame-&gt;cur_pc) - b-&gt;byte_code_buf - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pc &lt; <span class="number">0</span> || pc &gt; b-&gt;byte_code_len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回以pc为下标的数组值，根据上面的设置，1则表示命中</span></span><br><span class="line">    <span class="keyword">return</span> b-&gt;debugger.breakpoints[pc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>技术</category>
        <category>quickjs</category>
      </categories>
      <tags>
        <tag>quickjs</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记</title>
    <url>/2017/04/13/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>一个小的专题系列，记录自己对UE4引擎的学习过程。</p>
<ol>
<li><a href="/2017/04/13/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="开篇">开篇</a></li>
<li><a href="/2017/04/16/%E8%AE%BAUE4%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/" title="论UE4学习的正确方法">论UE4学习的正确方法</a></li>
</ol>
]]></content>
      <categories>
        <category>UE4学习笔记</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>从底层看程序执行过程：寄存器，cpu和x86汇编简介</title>
    <url>/2017/06/04/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%9C%8B%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8Ccpu%E5%92%8Cx86%E6%B1%87%E7%BC%96%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本篇是我本人博客中的专题“追根溯源 从C++到汇编”中的开篇。这是我第一次尝试写一个系列的文章出来与大家分享。如果有什么疏漏，欢迎大家指正。</p>
<p>为了阐述C++和汇编的关系，我觉着有必要简单介绍下汇编知识和一些计算机的基本组成。本篇的内容尽量保持简短。本篇的目的是为了后续的讲解做一个基础性的铺垫与简介，点到即止。</p>
<p>本文假定读者没有任何汇编基础知识。如果有读者对汇编很熟悉，可以略过本篇，参看系列后续的文章。</p>
<span id="more"></span>

<h1 id="疑惑：程序到底是怎么执行的"><a href="#疑惑：程序到底是怎么执行的" class="headerlink" title="疑惑：程序到底是怎么执行的"></a>疑惑：程序到底是怎么执行的</h1><p>现代计算机自图灵机理论诞生以来经历了高速发展。互联网时代，网络和移动平台正在深刻地改变这个社会。作为程序员，我们每天都在产出代码，这些代码在特定的平台和运行时系统支撑下运行，我们都早已习以为常。<br>但是如果你问一个程序员：你写的程序为什么能执行？大概他会一愣，然后抛出各种理论：因为编译器啊，因为jvm运行时啊，因为语言机制啊等等不一而足。其实这个问题就好比你去问一个大学生：1+1=2是个什么原理。也许在程序员看来，“程序为什么能运行”根本就不是问题，或者说算是个哲学问题？</p>
<p>其实很多时候，我们都不会去思考这种问题，因为它太基础，但是今天，我想尝试从汇编的角度解释下这个问题。</p>
<h1 id="从汇编层面解释程序执行"><a href="#从汇编层面解释程序执行" class="headerlink" title="从汇编层面解释程序执行"></a>从汇编层面解释程序执行</h1><h2 id="1-cpu工作原理"><a href="#1-cpu工作原理" class="headerlink" title="1. cpu工作原理"></a>1. cpu工作原理</h2><p>这个话题扯开来说很大，我们尽量简单点理解它。</p>
<h3 id="1-1-机器码与指令集"><a href="#1-1-机器码与指令集" class="headerlink" title="1.1 机器码与指令集"></a>1.1 机器码与指令集</h3><p>我们都知道，cpu是计算机的逻辑运算核心。我们写的程序代码，在编译为二进制后，最终会由cpu来执行（当然，gpu现在也能执行运算，这个我们暂且不表）。那为什么cpu能够理解二进制的0101代表什么意思？因为cpu指令集。</p>
<p>不同的cpu在设计的时候，就被设计为支持某种指令的编码格式，我们称之为cpu指令集。不同的cpu支持不同的指令集。比如我们经常听到的MMX，SSE，都是指令集的一种。使用软件可以查询不同cpu支持的指令集，比如下面一张图：</p>
<p>Paste_Image.png<br>可以看到i5处理器已经支持了很多的指令集。</p>
<h3 id="1-2-执行过程"><a href="#1-2-执行过程" class="headerlink" title="1.2 执行过程"></a>1.2 执行过程</h3><p>CPU的基本工作是执行存储的指令序列，即程序。程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程。几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回。</p>
<p>我们可以简单理解为，cpu在控制器，存储器，数据总线等多种部件的协调下，以一种流水线的方式取出要执行的二级制代码序列，使用内部的指令集来理解并执行每一条指令。这其中又会涉及到指令周期，时钟周期，cpu主频等概念。一个cpu的内部结构图大概如下图所示：</p>
<p><img src="/2017/06/04/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%9C%8B%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8Ccpu%E5%92%8Cx86%E6%B1%87%E7%BC%96%E7%AE%80%E4%BB%8B/IMG_2022-03-21-10-20-52.png"></p>
<h2 id="2-x86汇编和二进制机器码"><a href="#2-x86汇编和二进制机器码" class="headerlink" title="2. x86汇编和二进制机器码"></a>2. x86汇编和二进制机器码</h2><p>按照前面我们所说，不同的cpu支持不用的指令集（其实这里的概念应该从架构上来说）。也就是说，不同的cpu架构其实存在不同的汇编语言。在pc上广泛使用的cpu架构和汇编是intel公司的80x86系列和对应的x86汇编。<br>汇编指令可以通过汇编编译器翻译成对应的二进制指令，进而由cpu直接执行。汇编指令和二进制机器码直接对应，可以通过查阅intel的cpu技术文档了解这种对应关系的具体细节。</p>
<h2 id="3-寄存器的概念和x86-cpu中的寄存器"><a href="#3-寄存器的概念和x86-cpu中的寄存器" class="headerlink" title="3. 寄存器的概念和x86 cpu中的寄存器"></a>3. 寄存器的概念和x86 cpu中的寄存器</h2><p>关于寄存器的基本概念，百度百科是这样解释的</p>
<blockquote>
<p>在计算机领域，寄存器是CPU内部的元件，包括通用寄存器、专用寄存器和控制寄存器。寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。<br>寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。</p>
</blockquote>
<p>简单点理解，寄存器是最高速的内存单元，与cpu直连，拥有最快的访问和存取速度。我们一般意义上的内存，比之寄存器，速度上就没得比了。寄存器的意义在于，为cpu提供了一种快速速度存取途径，加速了cpu的运行速度。</p>
<blockquote>
<p>32位CPU所含有的寄存器如下：<br>4个数据寄存器(EAX、EBX、ECX和EDX)<br>2个变址和指针寄存器(ESI和EDI)<br>2个指针寄存器(ESP和EBP)<br>6个段寄存器(ES、CS、SS、DS、FS和GS)<br>1个指令指针寄存器(EIP)<br>1个标志寄存器(EFlags)</p>
</blockquote>
<p>这些寄存器的作用，在此不做详细解释。在x86汇编中，我们会直接使用这些寄存器来进行运算。因为本篇并不是一个x86汇编的教学帖，我们会在后面的讲解中对用到的寄存器做一些补充说明。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本篇在此打住，也许各位看官仍然有很多不理解的部分，因为本篇的介绍实在是有些过于简单。但是相信我，我们的主题从来都不是机器码，二进制，汇编。我们会在后续的章节中，探究一些关于C++语言层面的问题，又或者是一些代码安全问题。我会努力把更多精彩的文章带给大家，我们拭目以待。</p>
<p>参考资料<br><a href="https://blog.csdn.net/cc_net/article/details/10419645">计算机原理学习（1）– 冯诺依曼体系和CPU工作原理</a><br><a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fr=aladdin">百度百科-寄存器</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>前人的智慧结晶——有感于软件设计模式</title>
    <url>/2022/03/13/%E5%89%8D%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E7%BB%93%E6%99%B6%E2%80%94%E2%80%94%E6%9C%89%E6%84%9F%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="软件开发面临的问题"><a href="#软件开发面临的问题" class="headerlink" title="软件开发面临的问题"></a>软件开发面临的问题</h1><p>对于程序员来说，使用程序解决现实生活中的各种实际问题是我们的主要任务。</p>
<p>在软件行业发展的早期，受限于硬件性能和计算机的普及程度，程序的规模都很小，解决的也都是一些相对简单的问题。在这个时期，结构化的程序设计被认为是软件开发的最佳实践。我们用一个个函数和变量来组织程序，以函数组织功能，以函数间的相互调用来组织起更复杂的逻辑，解决更实际的问题。</p>
<p>但是随着IT行业的发展，在摩尔定律之下，硬件性能已经有了飞跃式的提升，软件所关注问题的复杂度也在成倍提升。但是这里存在一个矛盾点：机器可以处理的问题复杂度是远超人脑的，随着硬件性能的提升，这个差距还会进一步放大。这种急速膨胀的软件复杂度给程序员造成了沉重的脑力负担。所以IT圈发明了高层抽象，各种应用开发框架，编程范式，编程思想，用以缓解这种越发尖锐的问题。</p>
<p>设计模式也是其中的一种重要的解决方案，在经典著作《设计模式 可复用面向对象软件的基础》一书中，Gof对前人的智慧进行了总结，提出了23种被广泛使用的设计模式并对它们进行了深入探讨。</p>
<p>本文中我们并不对设计模式本身进行探讨，感兴趣的同学可以去通读设计模式全书，相信会大有裨益。我们在本文中所要讲述的是我自己对对设计模式的几点思考。</p>
<span id="more"></span>

<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><blockquote>
<p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动<br>——Alexander</p>
</blockquote>
<p>设计模式代表了最佳实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<p>所以设计模式是一种类似<strong>经验公式</strong>的东西，是前人总结出来的对某类问题的通用解决方案。我们学习和使用设计模式的原因在于借助这些最佳实践解决软件设计中的某些常见问题。</p>
<h1 id="设计模式的本质"><a href="#设计模式的本质" class="headerlink" title="设计模式的本质"></a>设计模式的本质</h1><p>设计模式有很多种，我们使用设计模式来构建可伸缩性的代码以应对需求变更，但为什么？为什么那设计模式为何拥有这种能力？<br>在软件工程的实践之中，我们一直倡导 <strong>“高内居低耦合”</strong>，设计模式与这个目标是一致的，只是侧重于不同的方面：<br><strong>高内聚低耦合主要是针对设计而言的</strong>，通过模块设计上的合理划分和整体的架构合计；<strong>设计模式则主要是针对修改而言的</strong>，它关注于在某些特定场景下采用特定的设计以限制修改的范围，核心关注点在于 ”控制变化“。**</p>
<p>我们思考这样一个问题：</p>
<blockquote>
<p>如果需求的变更或者后续功能的扩展需要在代码的多个部分进行修改，我们就要对这些所有修改的部分进行详尽的测试，以确保所有的修改没有破坏现有逻辑。</p>
</blockquote>
<p>直觉上可能认为这并不是一个很困难的事情，但当项目规模很大之后，这种由修改带来的额外测试工作量是很巨大的，而且某些边界条件很难被测试覆盖到进而由此引入潜在的问题，对软件的稳定性造成危害。这时候最好的情况就是，修改被限定在特定的范围内，尽可能小地对现有代码造成影响。<br>这就是设计模式的思路：通过对特定的问题的抽象设计，将变化的部分抽离出来做成接口（模板方法等），或将事件的发送和处理过程抽象并解耦合（观察者模式等）来做到抽离变化或依赖解耦，又或者是将对象的创建过程进行抽象以避免后续添加新的对象类型时创建代码和具体类型的耦合（工厂方法等），这些所有的抽象都是为了在后续的修改中代码中可能的化部分进行隔离和控制。</p>
<h1 id="抽象的代价"><a href="#抽象的代价" class="headerlink" title="抽象的代价"></a>抽象的代价</h1><p>C++语言的一个核心原则就是**零开销抽象(Zero cost Abstraction)**，也就是说C++提供的大部分抽象机制都不会带来额外的性能开销（或开销非常小）。从这里我们要认识到一点：抽象是有代价的，设计模式作为代码抽象的一种，它会付出代价：</p>
<ol>
<li>代码量增加和可读性下降</li>
<li>性能降低</li>
</ol>
<p>只是在大部分场景下，这些代价相对于它们带来的应对修改时的弹性优势来讲是值得的。在接触到嵌入式平台上的开发工作后，我更深刻地意识到架构设计和抽象所带来的开销并非在所有情况下都可以忽略，在一些极端性能敏感的领域，我们要慎用抽象。<br>还有一种情况值得我们警惕：对设计模式的滥用。<br>设计模式并非为了炫技而存在，我们要对它保持克制，不要做无谓的抽象，很多时候适当时机的重构比大而全的抽象要来的实在。对设计模式，我的观点是：过分的抽象和对模式的滥用带来的危害更大，滥用不如不用。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>阳光</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅的智慧——听《硅谷来信》节目有感</title>
    <url>/2017/10/22/%E4%BC%98%E9%9B%85%E7%9A%84%E6%99%BA%E6%85%A7%E2%80%94%E2%80%94%E5%90%AC%E3%80%8A%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1%E3%80%8B%E8%8A%82%E7%9B%AE%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>我是在去年订阅的《硅谷来信》，具体的月份已记不得，只记得天气很凉，大概是在十一月或者十二月。</p>
<p>这个栏目得到app上的一款付费内容，由硅谷投资人吴军老师每天分享一些话题进行深入讨论组成。开始只是觉着，自己需要学点东西，对这个节目的期待度也并没有多高。但是每天去听一篇，逐渐下来，直至今日，《硅谷来信》的所有节目播放完之后，才发觉，自己面前的是一座宝库。这些散落在艺术，职场，人生哲理，科学思维等等一系列主题中的内容，非常深刻地影响了我对这个世界方方面面的看法。在此非常感谢吴军老师的辛勤耕耘。</p>
<p>如果说我收获了什么，细细想来，会有很多，因为时间很长而且作者的在生活的方方面面都有不俗的见解，所以很难统一地论述整个过程中带给我的各种思考。但是我认为，最重要的一点大概就是：人需要拥有生活的智慧，它让生活本身变得更优雅。</p>
<span id="more"></span>

<p>作为一个年不及而立的光棍汉，我想我可能不是能那么理直气壮地去谈论生活，这会让人觉得是一种对生活的夸夸其谈。但是每一个时期，人总会有一些或成熟，或不成熟的想法，把它们记录下来，然后让时间证明这些想法的幼稚，对未来的自己会更有实践意义。所以我仍然会尝试把一些不成熟的东西写出来，写给我自己。如果将来的我注定会讨厌现在的自己，那对我来说并不是某种不能接受的情况，人应当成长，应当变得更好，应当在成长的过程中留下某些痕迹。这并不是因为这些痕迹值得纪念，恰恰是因为，我们需要对自己的成长本身做出一些注脚。我希望自己会是一个鄙视过去的人，相比缅怀过往，这让我觉着自己更是一个能活在当下的人。</p>
<p>吴军老师一篇关于《向死而生》的文章对我有很大的触动。文中吴军老师谈到了他对死亡的态度，对亡父的悼念，以及对待时间的看法。一句“除死无大难”，把生和死的界限，仍然活着的人对死亡的无奈生动地摆在人们面前。不管我们是否承认，时间分分秒秒都在流逝。我们终将老去，然后面临死亡。以前我从来没有以这样的一个角度看待我们的生活：因为人是会死的，所有每个人的时间有限。因为每个人的时间有限，所以并不是所有的事情都值得做。因为并不是所有的事情都值得做，所以我们需要取舍，需要更对时间更精细的控制，对未来更明确的最求，对生活更具体的期待。</p>
<p>细细思量，这种逻辑是严谨的，务实的，明确的。它犹如一道惊雷，振聋发聩，拥有足够惊醒每一个茫然无措，浑浑噩噩之人的伟力。所以我切实地被这种力量所警醒。我开始尝试审视自己乱糟糟的生活，自己曾经走过的道路。我发现过去的自己糟透了。犹如一根失去了思想的芦苇，自以为自在地漂浮在生活的溪流中，却对生活的一切变化无所适从。过去我一直认为自己是一个不算那么糟糕的人，遵守着这个社会的普遍价值观。现在我觉着，缺乏了自我思想，缺乏了自我驱动，缺乏了独立人格的自己，拥有的是一个丑陋的灵魂。</p>
<p>一切消极与逃避都是对时间的辜负，是一个懦夫躲在失败的角落下的自欺欺人。如果我们能意识到，时不我待，也许我们就会变得更有勇气。因为某些人清晰地知道，不远的将来，我们会面临什么，没有人能逃避，生命的一切都将终结。所以生活需要被规划，我们应当变得更努力，去做一个更好的自己，去懂得欣赏美，发现美，创造美，仅仅是因为，不希望在行将就木的年龄才幡然悔悟，自己错过了生命中太多的美好。</p>
<p>很多时候，知识并不等同于智慧。智慧来源于知识，来源于对生活最细致的考量。智慧是一种更高深的知识的体系，它让我们变得优雅。《硅谷来信》触及的，是人生最本质的东西：懂得发现并拥抱生命中一切美好的东西。它讲述的是这样一种关于优秀，关于优雅的智慧。</p>
<p>也许变得优雅是一项大工程，因为你需要涉猎很多方面的知识才能让你的生活本身变得更好。所以我们需要更多的关于美学上的修养来帮助我们发现生活中潜在的美好。人在满足了温饱之后，就需要更多的精神食量以充实自我，欣赏音乐，文学，绘画，是因为这些东西带来了切实的美的享受。人们欣赏这种美，因为它们在特定的方面达到了某种极致。发现并追随美的过程是我们走向更高价值的天梯。</p>
<p>当然，不得不承认，我至今仍然算作一个庸俗的人。希望以后的自己能拥有一个更加充实的内心。需要知道，活着只是基础，它不是生活，起码不是全部的生活，我们应当对生活有更高的追求。</p>
<p>如果说优秀是一种习惯，那么优雅，更是一种优秀的极致体现。愿每个人都能拥有优雅的生活，因为我们的时间是有限的，为了那可期的未来，请加倍努力地生活。</p>
<p>2017.10.23 1:57:58 于上海</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>小议程序员的自我修养</title>
    <url>/2017/01/10/%E5%B0%8F%E8%AE%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<p>元旦过去，2016年已过，崭新的2017已至。作为一名程序员，在有过一段时间的从业经历后，我们有了一些收获，也新增了很多疑惑。在外行眼里，我们是一个奇怪而神秘的群体：终日对着电脑，钻研所谓的技术。也许有些不善言辞;也许会为了技术上的分歧面红耳赤;也许加班是一种生活的常态；也许下班时间仍然会对着电脑继续写写画画。。。</p>
<p>其实程序员这个群体并不神秘，在外人眼里，我们也许是互联网时代的弄潮儿，我们自己却知道，为了紧跟互联网时代的步伐，我们有面临这怎样的压力。我们忙忙碌碌的身影背后，是一颗追求上进一步的心。彼时我们自嘲为码农，却梦想有一天走出自己的一方天地。无奈世间之事纷纷扰扰，技术日新月异：语言，工具，框架，热点···每天都在推陈出新。每个时刻，你都仿佛面临着很多个选择，也太容易在这些令人眼花缭乱的技术洪流中迷失。</p>
<p>也许，是时候静下心来，让自己脱离那些重复而略显徒劳的追逐游戏，重新地审视自己，去发现编程世界中程序员应该具有怎样的自我修养。</p>
<h2 id="匠心如一"><a href="#匠心如一" class="headerlink" title="匠心如一"></a>匠心如一</h2><p>在古代，中国人讲究一个匠心独运，讲究工匠精神。那何为匠心？庖丁解牛的故事大概是一个最好的注脚：<br>庖丁为梁慧王杀牛，技艺之精湛，以至于梁慧王发出了“善哉！技盖至此乎”的惊叹。对此，庖丁本人的解释是“臣之所好者道也，进乎技矣”。<br>技近乎道，这应该也是一个程序人的追求。对待程序，始终要秉持一种技术人的倔强，磨砺自身，精研技艺。对问题解决之道的上下求索，对技巧的不断钻研，对软件质量的孜孜追求，始终是我们作为技术人员前进的最大动力。</p>
<p>在这个快节奏的社会，我们仍然坚持对工匠精神的追求。认真而用心地对待自己写过的每一个程序，这是对工作的负责，也是对自己的负责。做好程序，也是在做好自己。</p>
<h2 id="持之以恒"><a href="#持之以恒" class="headerlink" title="持之以恒"></a>持之以恒</h2><p>作为技术人，不仅要做到敏而好学，而且还要敏而善学。技术对一个人的学习能力提出了很高要求。从来没有人生而知之，技术的道路上，我们需要不断地学习。古往今来，从未有不爱学习，不善学习，不持之以恒学习的人，可以做好技术一道。一事，日为之易，月为之易，而年为之又何如？</p>
<p>技术人的持之以恒，不仅体现在学习本身，还在于学习方向的选择。你需要把自己变成一个特定领域的技术专家，成为一个偏才怪才，好过一个碌碌无为的全才。深思熟虑之后，抓住一条脉络，集中精力攻其一处，构建自己的技术栈，这才是程序员安身立命之本。善于解决问题，成为权威和专家，是在我看来持之以恒的另一种诠释。</p>
<h2 id="居安思危"><a href="#居安思危" class="headerlink" title="居安思危"></a>居安思危</h2><p>作为程序员，我们每个人都应该有忧患意识。须知时不我待，只争朝夕。</p>
<p>正所谓人无远虑，必有近忧。安逸的生活会磨去我们的棱角，消磨我们的斗志，腐化我们的理想，降低我们的追求。须知技术一途，大浪淘沙，跟不上时代的人，注定会被时代所淘汰。</p>
<p>危机意识会敦促我们挑灯夜战，埋头钻研。作为一个程序员，我们面临着工作和生活的压力，学习的压力，技术更新换代的压力，只有居安思危，拿出自己的全部精力去做最好的自己，才能争的人先。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从今天起，做一个有追求的人。靠自己的技术安身立命，靠不懈的追求挣得人先。</p>
<p>希望自己能成为一个合格的程序员，一个好程序员，如若如此，莫大荣幸。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>自我修养</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全问题探讨-并发，同步和线程安全</title>
    <url>/2017/05/01/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%8E%A2%E8%AE%A8-%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>如果你不确定，请先停下来，自己考虑这个问题并审视你的代码，直到你确定答案是YES。如果我们不能保证基本的线程安全，那我们可能要面临一个定时炸弹：程序可能会在一个只有天知道的时间点崩溃。</p>
<p>很多人对这种多线程bug感到痛苦而绝望，因为它总在不经意间让你的程序变得一团糟。</p>
<h1 id="为什么存在“线程安全”问题。"><a href="#为什么存在“线程安全”问题。" class="headerlink" title="为什么存在“线程安全”问题。"></a>为什么存在“线程安全”问题。</h1><p>从”线程”的语义上来说，可以理解为在一个进程中提供的多条代码执行路径。在概念上，进程是拥有资源的最小单位，线程是CPU调度的最小单位。在进程中，多个线程可以共享相同的资源。这种“共享”本身就带来了多线程编程中的<strong>线程安全</strong>问题。</p>
<span id="more"></span>

<h2 id="1-从系统底层看问题-抢占式多任务带来的写入困境"><a href="#1-从系统底层看问题-抢占式多任务带来的写入困境" class="headerlink" title="1. 从系统底层看问题-抢占式多任务带来的写入困境"></a>1. 从系统底层看问题-抢占式多任务带来的写入困境</h2><p>如果我们在多个线程中给一个变量赋值，会存在什么问题？</p>
<p>假设我们有一个变量int i = 10；它能被线程t1和t2之间共享访问。t1和t2都会对i的值进行写入。假设我们在单核上运行这个程序，则系统需要给两个线程都分配cpu时间片。</p>
<ol>
<li>假设t1从内存中读取了i的值，此时i是10，它把i的值+1，准备把11这个新值写入到内存中。 此时它的时间片耗尽</li>
<li>系统执行了线程调度，t1的执行现场被保存，t2获得执行。它也去读取i的值，此时i的值仍然是10，它也把i的值+1，然后把11写入了内存中。</li>
<li>t1再次被调度，此时它也把11写入了内存中。</li>
</ol>
<p>这里我们就会发现问题：</p>
<p>由于线程调度的不可预测性，我们在多线程中对共享变量的写入出现了错误，程序的执行期行为和编程者的预期不符。</p>
<p>上述讨论发生在单核cpu上，单核cpu的中断发生在指令边缘，只要能在一条指令中完成的操作就不会存在被打断的风险，也就不存在上述的<strong>写入困境</strong>。但是在多核时代，单条指令也会受到干扰。其根源是存在共享变量的代码并不是“可重入”的，对这种代码的执行结果受到执行顺序的影响。</p>
<h2 id="2-从语义层看问题-状态的一致性"><a href="#2-从语义层看问题-状态的一致性" class="headerlink" title="2. 从语义层看问题-状态的一致性"></a>2. 从语义层看问题-状态的一致性</h2><p>在程序的执行过程中，我们期望能够获得一致的状态，但是多线程会破坏这种状态，参考下面的例子：</p>
<p>假设我们写了有个小游戏，在这个游戏中，我们对着一个Monster开火，每次命中monster后减少它的hp，如果hp为0，则修改死亡标志位，杀掉它。<br>monster可能有如下的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span>&#123;</span><br><span class="line">    <span class="type">bool</span> bDie;</span><br><span class="line">    <span class="type">int</span> currHp;</span><br><span class="line">    <span class="type">int</span> maxHp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们使用另一个线程检测monster的状态，一旦发现monster已死亡(currHp = 0或者bDie = true)，我们就让它重生，重置它的hp为maxHp，并修改死亡标志位为false。然后程序按如下的情况执行:</p>
<ol>
<li>某次攻击后，currHp = 0,攻击线程准备将bDie修改为true，但是此时发生了线程调度，bDie标志位还没有被修改。</li>
<li>复活线程被调度，它发现currHp = 0，然后执行复活monster的逻辑： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bDie = <span class="literal">false</span>;</span><br><span class="line">currHp = maxHp;</span><br></pre></td></tr></table></figure></li>
<li>攻击线程再次被调度，它执行了上次被打断的动作，修改了bDie为true。</li>
</ol>
<p>然后，我们得到了一个currHp不为0但是却已经“死亡”的monster对象。这种情况就是一种典型的语义中间态，虽然变量本身的值不存在问题，但是它们却构成了一个非法的组合，有违语义正确性。</p>
<h1 id="解决之道"><a href="#解决之道" class="headerlink" title="解决之道"></a>解决之道</h1><h2 id="1-系统层面的保证-原子操作"><a href="#1-系统层面的保证-原子操作" class="headerlink" title="1. 系统层面的保证-原子操作"></a>1. 系统层面的保证-原子操作</h2><p>操作系统会提供”原子操作”来解决多线程写入带来的不一致问题。</p>
<p>原子操作保证这个操作在执行时不会被打断，它所操作的资源也不会被其它核心访问和修改。对具体实现方式感兴趣的同学可以参考<a href="http://blog.csdn.net/vividonly/article/details/6599502">linux内核原子操作的实现</a>：</p>
<blockquote>
<p>在X86平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU上有一根引线#HLOCK pin连到北桥，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。对于其他平台的CPU，实现各不相同，有的是通过关中断来实现原子操作（sparc），有的通过CMPXCHG系列的指令来实现原子操作（IA64）。</p>
</blockquote>
<h2 id="2-语义保证-锁机制"><a href="#2-语义保证-锁机制" class="headerlink" title="2. 语义保证-锁机制"></a>2. 语义保证-锁机制</h2><p><strong>锁</strong>是一个实现于操作系统内核中的机制，它保证同一时间只能有一个线程获取锁的所有权，其它的线程则阻塞，等待上一个线程释放锁后，重新竞争<strong>锁</strong>的所有权,胜利者得以执行，失败者等待下一轮竞争。</p>
<p>当我们在多线程中访问共享资源时，所有的访问点都必须使用锁来锁定，共同竞争对资源的访问权。这种机制提供了一个在多线程之间<strong>排队</strong>的机制：对共享资源的访问实际是<em>单线程</em>的，同一时间只有一个线程在访问资源。这也就是我们所谓的<strong>线程同步</strong>。</p>
<p>锁机制其实带来了一些资源的浪费，降低了多线程程序在临界资源上的运行效率。而且它引入的<strong>死锁</strong>问题同样让人头疼不已。</p>
<h1 id="新思路"><a href="#新思路" class="headerlink" title="新思路"></a>新思路</h1><p>长久以来多线程编程中的问题给程序员的生活平添了无数的bug。针对这个问题，也许我们可以从多线程并发的根源考虑，大概有两条路：</p>
<ol>
<li>函数式编程，消灭共享状态。典型代表：haskell</li>
<li>异步编程，消灭多线程。典型代表：nodejs</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文引用了如下资料，如原作者对此行为有任何异议，请联系本人撤销。</p>
<p><a href="http://blog.csdn.net/vividonly/article/details/6599502">linux内核原子操作的实现</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>编程随想录</title>
    <url>/2022/03/11/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    <content><![CDATA[<h1 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h1><p>时间总是过得比我们预想中的快，从2012年开始实习算起，我作为程序员的职业生涯也走到了第十个年头。<br>十年总是一个值得我们停下来思考和总结的时间节点。这其中发生了很多的事情，我的生活也与十年前有了天翻地覆的不同。所以我想留下点属于我自己的，关于编程的思考。</p>
<p>在计划中，这会是一个系列，主要聊编程相关的事情，留下自己对程序员的职业思考。</p>
<span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><a href="/2022/03/13/%E5%89%8D%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E7%BB%93%E6%99%B6%E2%80%94%E2%80%94%E6%9C%89%E6%84%9F%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="1. 前人的智慧结晶——有感于软件设计模式">1. 前人的智慧结晶——有感于软件设计模式</a>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>论UE4学习的正确方法</title>
    <url>/2017/04/16/%E8%AE%BAUE4%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="学习是一件快乐的事"><a href="#学习是一件快乐的事" class="headerlink" title="学习是一件快乐的事"></a>学习是一件快乐的事</h1><p>对于以为以技术谋生的程序员来说，自我学习是我们职业生涯中一直面对的一个问题。</p>
<p>很多时候，学习使我们应对行业变化的一种方法和手段，为了跟得上这个迅速变化的行业，我们需要时刻关注行业热点并进行选择性的跟进，以期能够在职业道路上占得先机，又或者在自己的领域内进行深入学习，提升自己解决实际问题的能力，成为领域内的专家，才能升职加薪，让自己的财务更加自由。技术追求和金钱追求，在某些时候是可以统筹对待的。</p>
<p>但是抛开这些客观因素，我们还应该看到，学习本身在主观上就应该是一件快乐的事情。“To be a better man” 本身就对技术人员充满了诱惑力：这种诱惑力使我们拒绝了游戏，拒绝了网剧，拒绝了娱乐节目，把每天的时间抽出来花在对技术的追求上。在我看来，一个好的技术人员，他应该首先是乐于学习的，这样才能拥有不断前进的原动力。</p>
<span id="more"></span>

<h1 id="自我学习能力的重要性"><a href="#自我学习能力的重要性" class="headerlink" title="自我学习能力的重要性"></a>自我学习能力的重要性</h1><p>经济学领域经常会讲<strong>成本是放弃了的最大代价</strong>。每当我们选择了花时间学习某项技术的时候，意味着我们花费了时间，这个代价不可谓不大。我们花费了周末的一整个下午用来学习，可能意味着我们为此放弃了和女朋友的午后漫步，放弃了本来可以进行的长跑健身，放弃了和朋友约时间聚餐，放弃了一场精彩的电影，放弃了一个慵懒惬意的午觉等等，不一而足。</p>
<p>正是基于这个理解，我们才讲，自我学习的能力尤为重要。拥有一个高效的学习方式，意味着我们可以花更少的时间就可以掌握一门新的技术，意味着我们可以把节约下来的时间用来享受生活。任何时候，生活是具体的，我们的最终追求，永远是让自己的生活更舒适而精彩。这其中，包括了自我学习的成就感，它是我们达成自我认同的一种方式，这种精神追求本身也从属于我们的生活。</p>
<p>所以，正确的学习方法，在提高效率的同时，也反馈出我们对卓越和高品质生活的进一步追求。</p>
<h1 id="我个人学习规划"><a href="#我个人学习规划" class="headerlink" title="我个人学习规划"></a>我个人学习规划</h1><img src="/2017/04/16/%E8%AE%BAUE4%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/04/16/%E8%AE%BAUE4%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/%E8%AE%BAUE4%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95.jpg" class title="论UE4学习的正确方法">


<p>我个人会按照这份思维导图来做，其实很多时候，我们所渴望的东西，就隐藏在持之以恒的背后。优秀属于那些以强大的内在驱动力把握住时间的人。愿自己也能成为一个优秀而有趣的人。</p>
]]></content>
      <categories>
        <category>UE4学习笔记</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>论程序员与最优解</title>
    <url>/2018/04/06/%E8%AE%BA%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8E%E6%9C%80%E4%BC%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="问题的开端"><a href="#问题的开端" class="headerlink" title="问题的开端"></a>问题的开端</h1><p>一直以来，我都认为我算是一名合格的程序员，或者叫IT工程师。理由如下：</p>
<ol>
<li>熟悉基础的编程框架和编程语言技巧，能完成日常开发任务。</li>
<li>对工作保有热情，手脚麻利，有责任心。</li>
<li>一直在持续学习，享受编程并解决问题的过程。</li>
</ol>
<p>但是最近工作中遇到一些事情，我开始意识到我自身存在的一些问题：</p>
<ol>
<li>不善沟通，容易习惯性消极。</li>
<li>代码质量差，很少一遍通过。经常出错，排错花了很多时间。</li>
<li>解决问题的能力差，遇到不熟悉的问题经常不得要领，无法真正地独立解决难题。</li>
<li>讨厌写复杂逻辑，涉及到算法相关的问题就发蒙。</li>
</ol>
<span id="more"></span>

<p>然后昨天去LeetCode上刷了个Medium难度的题，一个循环折腾了好久，自己构想好的解法总是跑不过test case，最后无奈拉出gdb去调试，仍然没有解决。直到今天上午整理了下思路，换了个方法写完调了几遍才最终跑过，效率也是仅仅排在后20%，令人汗颜。</p>
<p>这些事情让我开始思考一个问题： <strong>我是不是一个优秀的程序员？如果不是，那什么样的人才是？</strong> 想到这个问题的第一时间，我脑子里的答案是东晓同学：反应敏锐，可以在最短的时间内发现可能的问题点。思路清晰，按照一个严谨的逻辑方法逐步排查最终确认问题。这样的人可以算作一个优秀的程序员，相比之下我还差得很远。</p>
<h1 id="码农与IT工程师"><a href="#码农与IT工程师" class="headerlink" title="码农与IT工程师"></a>码农与IT工程师</h1><p>程序员的圈子里经常会以码农自嘲，自比为播撒代码的农民伯伯，干着些没有技术含量的活。相比之下，IT工程师的称呼就显得高大上很多，可以理解为使用工程思维和编程手段解决项目遇到的实际问题的一群人。</p>
<p>那么作为程序员，你到底是码农，还是工程师呢？这应该是一个这的思考的问题。</p>
<p>就我个人来说，我感觉我算是刚刚脱离了码农阶段，称一声工程师好像还有点为时过早。很多时候，写代码还停留在”快步小跑赶进度，千方百计少加班“这条思路上。大概跟自己自实习开始就混迹于各种小公司，见惯了加班催进度，代码一坨屎的行业生态有关。</p>
<p>仔细想想，这些坏习惯对我的影响还是挺大的，可谓流毒千里。我也就最近才开始改掉一直以来那种”拿到需求先开干，写到一半再重来“的莽夫作风，尝试先去思考一下怎么下手会更合适。当然，这个过程绝对不会花太长时间，很多时候都是简单想想，觉着靠谱就干了，偶尔也还是会有快写完了发现开始想的有问题这种倒灶事情发生，然后就是各显神通，想办法找补……我在喷别人的代码烂的同时，其实也贡献了为数不少的烂代码出来，罪过罪过。</p>
<p>其实这种小家子气的莽夫作风算是码农专属。还带着这种习气，只能说明一个程序员的工程师素养还有待加强。作为一名好的程序员，自己交付的代码应该是经过良好设计编码和测试的。很多时候，我们面对的都是一些普通的业务代码，本身没有什么深度，也很难体现出所谓的高层设计。但是尽管舞台很小，也不能成为毫无作为的借口，进而降低对自己的要求。宁可多花点时间思考，也要杜绝拍脑袋式的想当然。要时刻谨记，把自己定位成一名工程师，要对自己有着高要求，首先对自己些的代码进行细致的思考，争取一遍通过，减少甚至杜绝低级的bug，这样才是提高生产力，脱离低级趣味的捷径。</p>
<p>程序员的价值，绝不在于他能在最短时间内写出最多的看似可用实则垃圾的烂代码，这样的人只能成为码农，无法成为优秀的IT工程师。</p>
<h1 id="从最优解问题看IT从业者的价值体现"><a href="#从最优解问题看IT从业者的价值体现" class="headerlink" title="从最优解问题看IT从业者的价值体现"></a>从最优解问题看IT从业者的价值体现</h1><p>在LeetCode解答算法题的时候，我才深刻地理解到自己和 <strong>最优解</strong> 之间的差距。看着自己经过深思熟路几经修改提交上去的solution得了一个奇底无比的分数，这个感觉绝不会好受。</p>
<p>其实在面试的时候，我经常会被问道有关算法的问题，诸如 <em>快速排序</em>，<em>哈夫曼编码树</em>，<em>哈希算法</em> 之类。尤其是大厂，最是乐此不疲。从我个人角度来讲，我一直是对此不屑一顾的，觉着这只是厂商用来评判面试者的一个标准，是凭空捏造的需求，是实际项目中的屠龙之技。有点类似大家 <strong>面试造飞机，进去拧螺丝</strong> 的嘲讽之语。</p>
<p>在LeetCode上被虐之后，我觉着自己之前对 <strong>考算法</strong> 的理解有所偏颇。算法并没有多么的高大上，很多时候我们在项目中是能够用得上的。而且算法可以视作一个IT工程师的基本素养。它从一个侧面表征了一个开发人员的理论上限。这就好比算1+1等于几，小学生和大学生都可以。但是你说要算个不定积分，那小学生是不可能会算的。算法就是这样一种指标，它一方面反映了你能解决问题的高度，另一方面也能看出一个人的思维敏锐程度。算法毕竟是一种智力活动，聪明的人总能脱颖而出。</p>
<p>然后我们可以聊聊最优解的问题。算法中的最优解可以简单理解为跑test case的时间最短。当这个指标（最短运行时间）确定的时候，事情就变得有了可比性，可以量化。一个算法实现是否优秀，是否足够简洁明了，都是可以直观衡量的。每一个参与测试者都可以用最直接的方式看到，自己到底处在什么层次。那实际的编程工作中，其实我们面临的也是最优解的问题：如何在现有的代码基础上，有限的时间内，将需求用一种最简洁稳定的方式实现。一流的程序员是能看清这种问题的人，他们总能在有限的条件下寻求当前可能的最优解。这种最优不是技术上的，是一种综合的考虑。为了工程实现，他们可以做出各种设计上的妥协，甚至功能上的妥协，以得到他们想要的结果：在当前的项目条件下的近似最优解。</p>
<p>程序员或者说IT工程师并不是科学家：科学家眼里的最优是理论上的极值，他们并不考虑其实现难度；工程师关注的是工程上的实践，需要在复杂条件下做综合的考虑。</p>
<p>所以一个程序员的水平体现在他对计算机编程本质的理解以及建立在这种理解力基础之上的工程素养。解决项目中的实际问题，这是对IT工程师的基本要求。找到可能存在的最优解，这是一流程序员的不懈追求。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>追根溯源 从C++到汇编</title>
    <url>/2017/01/15/%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90-%E4%BB%8EC-%E5%88%B0%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>今天，我想讲的一个话题就是，作为一个C++程序员，<strong>如何从汇编层面理解C和C++<strong>。又或者是，</strong>如何理解C++中的对象模型</strong>，如何理解函数调用本身，如何增强程序的安全性等等。我想，这会是一个专题，在这里，我们会讨论一些更底层和更深入的话题。<br>我希望我能把我所掌握的东西，以一个更生动的形象展示给大家。</p>
<span id="more"></span>

<ol>
<li><a href="/2017/06/04/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%9C%8B%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8Ccpu%E5%92%8Cx86%E6%B1%87%E7%BC%96%E7%AE%80%E4%BB%8B/" title="从底层看程序执行过程：寄存器，cpu和x86汇编简介">从底层看程序执行过程：寄存器，cpu和x86汇编简介</a></li>
<li><a href="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" title="跳转，执行，返回：从汇编看函数调用">跳转，执行，返回：从汇编看函数调用</a></li>
<li><a href>C++对象内存模型解析（暂定）</a></li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>重构版Launcher开发实践01：CEF篇</title>
    <url>/2020/11/27/%E9%87%8D%E6%9E%84%E7%89%88Launcher%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%9ACEF%E7%AF%87/</url>
    <content><![CDATA[<h1 id="1-重构版Launcher的技术方案"><a href="#1-重构版Launcher的技术方案" class="headerlink" title="1. 重构版Launcher的技术方案"></a>1. 重构版Launcher的技术方案</h1><h2 id="简单的对比"><a href="#简单的对比" class="headerlink" title="简单的对比"></a>简单的对比</h2><p>多厂商Launcher本身是一个使用QT作为界面库，CEF作为内嵌浏览器，使用C++语言进行开发的桌面程序。多厂商Launcher存在很多的问题，在决定重构之后，对后续的技术方案进行了一番考量，具体的对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>多厂商</th>
<th>重构版</th>
</tr>
</thead>
<tbody><tr>
<td>Qt版本</td>
<td>5.6.3</td>
<td>5.12.6</td>
</tr>
<tr>
<td>CEF版本</td>
<td>76.0.3809.162 (支持XP+)</td>
<td>86.0.4044.132 (支持win7+)</td>
</tr>
<tr>
<td>VS版本</td>
<td>VS 2013</td>
<td>VS 2017</td>
</tr>
<tr>
<td>构建系统</td>
<td>VS工程+CMake</td>
<td>CMake</td>
</tr>
<tr>
<td>版本升级方式</td>
<td>大网易的补丁升级系统</td>
<td>ngl-pacman工具</td>
</tr>
<tr>
<td>打包方式</td>
<td>bash脚本和cmd脚本</td>
<td>bash脚本</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>下面是一些简单的说明：</p>
<ul>
<li>重构版Launcher不再支持xp，故Qt版本选用了最新的LTS版本，VS版本选用2017方便使用更新的C++标准。 </li>
<li>内嵌浏览器考虑过使用QtWebEngine，此模块是Qt官方对chromium进行的封装，可以方便地与Qt程序集成，但后续考虑到游戏内商城需要进行离屏渲染， QtWebEngine未开放相应接口，故放弃，继续使用CEF但对CEF版本进行了升级。</li>
<li>对工程结构进行了整理和简化，全部使用CMake进行构建，可以方便地跨平台，VS2017本身也对CMake提供了良好的支持。</li>
<li>大网易的补丁升级系统更适合对游戏进行升级，需要依次应用所有补丁，过于繁琐。创建了一个独立进程完成升级功能，可以跨版本进行升级。</li>
</ul>
<h2 id="内嵌浏览器需要完成的功能"><a href="#内嵌浏览器需要完成的功能" class="headerlink" title="内嵌浏览器需要完成的功能"></a>内嵌浏览器需要完成的功能</h2><p>Launcher本身是一个重Web的项目，开发过程中考虑过使用Electron来实现，但纯web技术栈做游戏Launcher存在不少的限制，安全性上也存在很大的挑战，最终走回了应用内嵌浏览器的解决方案。内嵌浏览器需要完成如下功能：</p>
<ul>
<li>提供浏览器环境，加载和显示网页。</li>
<li>将C++函数暴露给浏览器，提供底层数据存储，游戏下载，npl stub集成功能。</li>
<li>支持传入和触发JavaScript回调。</li>
<li>支持绑定native属性到JavaScript环境。</li>
<li>为网页提供跨页面数据访问和事件注册/触发功能。</li>
<li>提供离屏渲染功能用于显示游戏内商城。</li>
</ul>
<p>基于以上需求，重构版使用了一个开源的CEF QT封装层QCefView并对它进行了大量的改造，添加了基于Qt反射的函数和属性自动绑定层，对离屏渲染进行了实现。</p>
<h1 id="2-CEF介绍"><a href="#2-CEF介绍" class="headerlink" title="2. CEF介绍"></a>2. CEF介绍</h1><p>Chromium Embedded Framework (CEF)是一个将基于Chromium的浏览器嵌入到应用程序中的简单框架。</p>
<blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>The Chromium Embedded Framework (CEF)是一个由Marshall Greenblatt于2008年创建的开源项目，旨在开发基于Google Chromium项目的Web浏览器控件。CEF目前支持一系列编程语言和操作系统，可以很容易地集成到新的和现有的应用程序中。它从一开始就考虑到性能和易用性。基础框架包括通过本地库导出的C和C++编程接口，它们将宿主应用与Chromium和Blink的实现细节隔离。它提供浏览器控件和宿主应用程序之间的紧密集成，包括对自定义插件、协议、JavaScript对象和JavaScript扩展的支持。宿主应用程序可以选择性地控制资源加载、导航、上下文菜单、打印等，同时获得与Google Chrome浏览器相同的性能优势和HTML5技术支持。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>CEF项目依赖于由第三方维护的许多其他项目。CEF依赖的主要项目有：</p>
<ul>
<li>Chromium - 提供创建一个功能齐全的Web浏览器所需的网络堆栈、线程、消息循环、日志记录和进程控制等常规功能。实现允许Blink与V8和Skia通信的“平台”代码。许多Chromium设计文件可以在 <a href="http://dev.chromium.org/developers">http://dev.chromium.org/developers</a> 找到。</li>
<li>Blink（以前叫WebKit）——Chromium使用的渲染实现。提供DOM解析、布局、事件处理、呈现和html5 Javascript API。一些HTML5实现被分散在Blink和Chromium代码库之间。</li>
<li>V8 - JavaScript 引擎.</li>
<li>Skia - 用于渲染非加速内容的二维图形库。关于Chrome是如何整合Skia的更多信息可以在 <em><a href="http://www.chromium.org/developers/design-documents/graphics-and-skia">这里</a></em> 找到。</li>
<li>Angle - 为Windows实现的3D图形转换层，用于将GLES调用转换为DirectX调用。有关acclerated composing的更多信息，请访问 <em><a href="http://dev.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">此处</a></em> 。</li>
</ul>
<h2 id="CEF3实现细节"><a href="#CEF3实现细节" class="headerlink" title="CEF3实现细节"></a>CEF3实现细节</h2><p>自2013年1月以来，CEF3一直是CEF的推荐和支持版本。它通过Chromium Content API来使用与Chromium Web浏览器相同的多进程体架构。与使用单进程体架构的 CEF1（已废弃）相比，该体系结构具有许多优势：</p>
<ul>
<li>支持多进程运行模式</li>
<li>与Chromium浏览器共享更多代码</li>
<li>基于上一条，由于使用了“受支持”的代码路径，因此性能得到了改善，功能破坏次数更少。</li>
<li>更快地跟进Chromium更新以访问新功能<br>在大多数情况下，CEF3将具有与Chromium Web浏览器相同的性能和稳定性特性。</li>
</ul>
</blockquote>
<p>Chromium的多进程架构</p>
<blockquote>
<p><img src="/2020/11/27/%E9%87%8D%E6%9E%84%E7%89%88Launcher%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%9ACEF%E7%AF%87/IMG_2020-11-28-19-26-55.png"></p>
</blockquote>
<h1 id="3-C-和JavaScript的互调用"><a href="#3-C-和JavaScript的互调用" class="headerlink" title="3 C++和JavaScript的互调用"></a>3 C++和JavaScript的互调用</h1><h2 id="C-调用JavaScript"><a href="#C-调用JavaScript" class="headerlink" title="C++调用JavaScript"></a>C++调用JavaScript</h2><p>CEF提供了相应的接口可以直接使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">browser-&gt;<span class="built_in">GetMainFrame</span>()-&gt;<span class="built_in">ExecuteJavaScript</span>(<span class="string">&quot;__GDATA__.toogleLogin();&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript调用C"><a href="#JavaScript调用C" class="headerlink" title="JavaScript调用C++"></a>JavaScript调用C++</h2><h3 id="1-CefV8Handler接口"><a href="#1-CefV8Handler接口" class="headerlink" title="1. CefV8Handler接口"></a>1. CefV8Handler接口</h3><p>CEF提供了标准的函数执行接口CefV8Handler，所有Native方法都必须实现此接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CefV8Handler</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> CefBaseRefCounted &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//当JavaScript函数执行时会调用此接口</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Execute</span><span class="params">(<span class="type">const</span> CefString&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       CefRefPtr&lt;CefV8Value&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> CefV8ValueList&amp; arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">                       CefRefPtr&lt;CefV8Value&gt;&amp; retval,</span></span></span><br><span class="line"><span class="params"><span class="function">                       CefString&amp; exception)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现CefV8Handler接口"><a href="#2-实现CefV8Handler接口" class="headerlink" title="2. 实现CefV8Handler接口"></a>2. 实现CefV8Handler接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承CefV8Handler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QCefFunctionObject</span> : <span class="keyword">public</span> CefV8Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Execute</span><span class="params">(<span class="type">const</span> CefString&amp; name, CefRefPtr&lt;CefV8Value&gt; object, <span class="type">const</span> CefV8ValueList&amp; arguments, CefRefPtr&lt;CefV8Value&gt;&amp; retval, CefString&amp; exception)</span> OVERRIDE</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;function: %s executed!\n&quot;</span>, name.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-调用V8接口创建Native-JavaScript函数"><a href="#3-调用V8接口创建Native-JavaScript函数" class="headerlink" title="3. 调用V8接口创建Native JavaScript函数"></a>3. 调用V8接口创建Native JavaScript函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建handler</span></span><br><span class="line">CefRefPtr&lt;QCefFunctionObject&gt; functionHandler = <span class="keyword">new</span> <span class="built_in">QCefFunctionObject</span>();</span><br><span class="line"><span class="comment">//通过handler创建函数对象</span></span><br><span class="line">CefRefPtr&lt;CefV8Value&gt; func = CefV8Value::<span class="built_in">CreateFunction</span>(funcInfo.name.<span class="built_in">toStdWString</span>(), functionHandler);</span><br><span class="line"><span class="comment">//获取页面全局window对象</span></span><br><span class="line">CefRefPtr&lt;CefV8Value&gt; objWindow = context-&gt;<span class="built_in">GetGlobal</span>();</span><br><span class="line"><span class="comment">//将函数对象插入到window对象中</span></span><br><span class="line">objWindow-&gt;<span class="built_in">SetValue</span>(<span class="string">&quot;test&quot;</span>, func, V8_PROPERTY_ATTRIBUTE_NONE);</span><br></pre></td></tr></table></figure>
<h3 id="4-在控制台执行如下JavaScript函数"><a href="#4-在控制台执行如下JavaScript函数" class="headerlink" title="4. 在控制台执行如下JavaScript函数"></a>4. 在控制台执行如下JavaScript函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>
<p>得到输出：function: test executed!</p>
<h1 id="4-偷该偷的懒：自动绑定的缘由和构想"><a href="#4-偷该偷的懒：自动绑定的缘由和构想" class="headerlink" title="4. 偷该偷的懒：自动绑定的缘由和构想"></a>4. 偷该偷的懒：自动绑定的缘由和构想</h1><p>Launcher中界面主要由web构建，如果按照MVC模式进行分层，Web处于View和Controller层，C++更多时候充当一个model层：提供游戏下载安装信息，stub功能集成，窗口的打开关闭控制等。C++通过注册Native函数到JavaScript中，为web提供增强功能，以便web更好地实现业务功能。<br>基于这种逻辑分层关系，随着业务需求的变更，C++经常要和web协商添加新的接口，注册新的函数到JavaScript中，所以简化这个注册流程是很有必要的，可以有效地降低开发工作量。</p>
<h2 id="4-1-动机：手动注册的弊端"><a href="#4-1-动机：手动注册的弊端" class="headerlink" title="4.1 动机：手动注册的弊端"></a>4.1 动机：手动注册的弊端</h2><p>如果我们手动来给每一个C++函数做绑定，我们需要在两个项目中同时添加代码，繁琐而且容易出错。<br>在Browser进程响应IPC消息的时候，我们的代码中必然会出现一个如下分派代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (functionName == <span class="string">&quot;getWebId&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">//调用getWebId</span></span><br><span class="line">  <span class="keyword">auto</span> strWebId = obj.<span class="built_in">getWebId</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (functionName == <span class="string">&quot;startDownload&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">//调用startDownload</span></span><br><span class="line">  <span class="keyword">auto</span> gameVersion = params.<span class="built_in">GetString</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">auto</span> downloadPath=params.<span class="built_in">GetString</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> result = obj.<span class="built_in">startDownload</span>(gameVersion, downloadPath);</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为JavaScript是一种动态脚本，而C++是编译型强类型语言，因此收到IPC消息后要根据C++函数签名对参数数量和类型做合法性校验，写起来很繁琐。</p>
<p>在Render进程的CefV8Handler::Execute接口中，我们需要手动去拼接IPC消息，<br>每当添加一个新的JavaScript接口，都需要在此处添加新的序列化代码。这种重复性的工作最好能交给程序自动完成而不需要人工介入，这样就可以尽可能地简化工作量，提高开发效率。</p>
<p><strong>说了这么多，主要还是我们懒</strong></p>
<h2 id="4-2-可行性：IPC调用和本地调用的等价转换"><a href="#4-2-可行性：IPC调用和本地调用的等价转换" class="headerlink" title="4.2 可行性：IPC调用和本地调用的等价转换"></a>4.2 可行性：IPC调用和本地调用的等价转换</h2><p><strong>一个典型的JavaScript接口调用过程</strong><br><img src="/2020/11/27/%E9%87%8D%E6%9E%84%E7%89%88Launcher%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%9ACEF%E7%AF%87/IMG_2020-12-02-11-51-03.png"></p>
<p>可以看到，C++函数本身位于Browser进程（Launcher进程）中，JavaScript函数到额执行在render进程中，所以这里是一个典型的IPC跨进程调用过程。render进程中的函数只是一个stub，它仅用于将调用请求转发给browser进程。</p>
<p>当进行自动绑定的构想时，遇到的第一个问题就是：<br><strong>如果把JavaScript函数都变成了RPC调用，是否存在某些情况我们无法进行等价转换？</strong></p>
<p>实际情况是，RPC调用和本地调用在能力上讲是等价的，可以进行切换，调用者不会感知到一个调用到底是本地调用还是远程调用，RPC调用在web后端开发中已经大量应用。从软件设计上讲，软件应该是模块化的，高内聚，低耦合，必要时我们使用接口来进行模块间的通信，此时接口等价于一种消息。如果调用是跨进程的，使用IPC来进行进程间的通信，这两者没有什么本质区别，调用者并不关心这个调用是跨了“模块”还是垮了“进程”，我们可以把“进程”理解为模块概念的强化，进程间的资源是天然强制隔离的，通信必须完全依赖消息。</p>
<h2 id="4-3-解决思路：基于Qt反射实现自动注册"><a href="#4-3-解决思路：基于Qt反射实现自动注册" class="headerlink" title="4.3 解决思路：基于Qt反射实现自动注册"></a>4.3 解决思路：基于Qt反射实现自动注册</h2><p>CEF中C++函数调用是一个典型的IPC调用过程，render进程中仅存在一个stub函数，将函数调用序列化后通过IPC消息通知给browser进程，browser进程执行完真整的函数调用后，通过IPC消息将结果发送回render进程。<br>所以问题的关键是，如果我们能在render进程中拿到要注册的C++函数的完整函数签名（函数名，参数数量，参数类型），我们就可以以此为基础注册一个同名的JavaScript函数，当这个函数被调用时，将函数调用信息（函数名，参数等）序列化并通过CEF标准的IPC通信机制发送给browser进程。browser进程解析IPC消息，根据调用函数名查找函数元信息，校验调用参数并最终通过反射执行对应的C++函数，最后将执行结果通过IPC消息发回render进程，完成整个调用过程。</p>
<p>C++本身不支持反射但是Qt是支持的，可以在Qt元对象系统和反射的基础上实现自动绑定。</p>
<h1 id="5-实现细节"><a href="#5-实现细节" class="headerlink" title="5. 实现细节"></a>5. 实现细节</h1><h2 id="5-1-注册和绑定"><a href="#5-1-注册和绑定" class="headerlink" title="5.1 注册和绑定"></a>5.1 注册和绑定</h2><h3 id="1-browser进程中以指定的名字注册一个QObject的子类对象"><a href="#1-browser进程中以指定的名字注册一个QObject的子类对象" class="headerlink" title="1. browser进程中以指定的名字注册一个QObject的子类对象"></a>1. browser进程中以指定的名字注册一个QObject的子类对象</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;base&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectBase</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<h3 id="2-注册细节：遍历元对象，获取函数签名信息，写入共享内存"><a href="#2-注册细节：遍历元对象，获取函数签名信息，写入共享内存" class="headerlink" title="2. 注册细节：遍历元对象，获取函数签名信息，写入共享内存"></a>2. 注册细节：遍历元对象，获取函数签名信息，写入共享内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefObjectProtocol::registerJavaScriptHandlerObject</span><span class="params">(<span class="type">const</span> QString&amp; registerName, <span class="type">const</span> QObject* registerObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取元对象</span></span><br><span class="line">  <span class="keyword">auto</span> metaObj = registerObject-&gt;<span class="built_in">metaObject</span>();</span><br><span class="line">  QJsonObject registerObjInfo;</span><br><span class="line">  registerObjInfo.<span class="built_in">insert</span>(<span class="string">&quot;registerName&quot;</span>, registerName);</span><br><span class="line">  registerObjInfo.<span class="built_in">insert</span>(<span class="string">&quot;className&quot;</span>, metaObj-&gt;<span class="built_in">className</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; metaObj-&gt;<span class="built_in">methodCount</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">//获取函数名，函数签名，参数</span></span><br><span class="line">    functionInfo.<span class="built_in">insert</span>(<span class="string">&quot;functionName&quot;</span>, QString::<span class="built_in">fromUtf8</span>(metaMethod.<span class="built_in">name</span>()));</span><br><span class="line">    functionInfo.<span class="built_in">insert</span>(<span class="string">&quot;functionSignature&quot;</span>, QString::<span class="built_in">fromUtf8</span>(metaMethod.<span class="built_in">methodSignature</span>()));</span><br><span class="line">    functionInfo.<span class="built_in">insert</span>(<span class="string">&quot;returnType&quot;</span>, metaMethod.<span class="built_in">returnType</span>());</span><br><span class="line">    <span class="comment">//遍历参数列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; metaMethod.<span class="built_in">parameterCount</span>(); j++) &#123;</span><br><span class="line">      <span class="comment">//获取参类型名和参数名，添加到Json Array中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到Json Array</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将序列化好的函数注册信息Json写入到共享内存</span></span><br><span class="line">  <span class="built_in">writeJsObjectRegisterInfo</span>(jsonStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-render进程初始化时解析Json信息并完成注册"><a href="#3-render进程初始化时解析Json信息并完成注册" class="headerlink" title="3. render进程初始化时解析Json信息并完成注册"></a>3. render进程初始化时解析Json信息并完成注册</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefJavaScriptBinder::initRegisterObjectsData</span><span class="params">(<span class="type">const</span> QString&amp; jsonData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//解析注册信息，将函数签名信息反序列化为结构体，最终以注册名为key保存在map里</span></span><br><span class="line">    ...</span><br><span class="line">    m_javaScriptMetaObjectMap[regName] = objectInfo;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-浏览器对象创建时（OnContextCreated接口调用），注册所有的C-函数"><a href="#4-浏览器对象创建时（OnContextCreated接口调用），注册所有的C-函数" class="headerlink" title="4. 浏览器对象创建时（OnContextCreated接口调用），注册所有的C++函数"></a>4. 浏览器对象创建时（OnContextCreated接口调用），注册所有的C++函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">QCefJavaScriptBinder::bindAllObjects</span><span class="params">(CefRefPtr&lt;CefV8Value&gt; parentObj, CefRefPtr&lt;CefBrowser&gt; browser, CefRefPtr&lt;CefFrame&gt; frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QCefJavaScriptEnvironment* pJsEnv = <span class="keyword">new</span> <span class="built_in">QCefJavaScriptEnvironment</span>();</span><br><span class="line">    QStringList allRegisterNames = m_javaScriptMetaObjectMap.<span class="built_in">keys</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; regNameKey : allRegisterNames) &#123;</span><br><span class="line">        <span class="comment">//一些必要的校验判断</span></span><br><span class="line">        ...</span><br><span class="line">        JavaScriptMetaObject&amp; metaInfo = m_javaScriptMetaObjectMap[regNameKey];</span><br><span class="line">        CefRefPtr&lt;QCefJavaScriptObject&gt; jsObj = <span class="keyword">new</span> <span class="built_in">QCefJavaScriptObject</span>(metaInfo, browser, frame);</span><br><span class="line">        <span class="comment">//根据函数注册信息完成C++函数到JavaScript环境的自动注册</span></span><br><span class="line">        jsObj-&gt;<span class="built_in">registerObject</span>(pJsEnv, regNameKey.<span class="built_in">toStdWString</span>(), parentObj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pJsEnv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-注册细节："><a href="#5-注册细节：" class="headerlink" title="5. 注册细节："></a>5. 注册细节：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefJavaScriptObject::registerObject</span><span class="params">(QCefJavaScriptEnvironment* pJsEnv, CefString registerName, CefRefPtr&lt;CefV8Value&gt; cefParentObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历找到正确的parent对象</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果当前对象为空，创建它</span></span><br><span class="line">    <span class="keyword">if</span> (!currObjValue)</span><br><span class="line">        currObjValue = CefV8Value::<span class="built_in">CreateObject</span>(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//遍历所有的function注册信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> JavaScriptMetaMethod&amp; funcInfo : m_metaObject.functions) &#123;</span><br><span class="line">        <span class="comment">//创建handler实例用于响应JavaScript函数调用</span></span><br><span class="line">        CefRefPtr&lt;QCefFunctionObject&gt; functionHandler = <span class="keyword">new</span> <span class="built_in">QCefFunctionObject</span>(funcInfo, m_browser, m_frame);</span><br><span class="line">        <span class="comment">//使用handler创建JavaScript函数，它是一个CefV8Value的实例</span></span><br><span class="line">        CefRefPtr&lt;CefV8Value&gt; func = CefV8Value::<span class="built_in">CreateFunction</span>(funcInfo.name.<span class="built_in">toStdWString</span>(), functionHandler);</span><br><span class="line">        <span class="comment">//将handler保存在map中，方便后续访问</span></span><br><span class="line">        m_functionMap.<span class="built_in">insert</span>(funcInfo.name, functionHandler);</span><br><span class="line">        <span class="comment">//将新创建的函数对象插入到当前JS对象中</span></span><br><span class="line">        currObjValue-&gt;<span class="built_in">SetValue</span>(funcInfo.name.<span class="built_in">toStdWString</span>(), func, V8_PROPERTY_ATTRIBUTE_NONE);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-QCefFunctionObject-Execute实现"><a href="#6-QCefFunctionObject-Execute实现" class="headerlink" title="6. QCefFunctionObject::Execute实现"></a>6. QCefFunctionObject::Execute实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefFunctionObject::Execute</span><span class="params">(<span class="type">const</span> CefString&amp; name, CefRefPtr&lt;CefV8Value&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CefV8ValueList&amp; arguments, CefRefPtr&lt;CefV8Value&gt;&amp; retval, CefString&amp; exception)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建CEF标准的IPC消息，消息名为QCEF_INVOKENGLMETHOD</span></span><br><span class="line">    CefRefPtr&lt;CefProcessMessage&gt; msg = CefProcessMessage::<span class="built_in">Create</span>(QCEF_INVOKENGLMETHOD);</span><br><span class="line">    <span class="comment">//获取调用参数列表</span></span><br><span class="line">    CefRefPtr&lt;CefListValue&gt; args = msg-&gt;<span class="built_in">GetArgumentList</span>();</span><br><span class="line">    <span class="comment">//获取browserId和frameId，前者是浏览器内部唯一标识，后者是frame内部唯一标识</span></span><br><span class="line">    <span class="type">int</span> browserId = m_browser-&gt;<span class="built_in">GetIdentifier</span>();</span><br><span class="line">    int64 frameId = m_frame-&gt;<span class="built_in">GetIdentifier</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//消息格式: browserId, frameId, C++类名，调用函数名，回调函数签名，参数列表</span></span><br><span class="line">    args-&gt;<span class="built_in">SetString</span>(idx++, QString::<span class="built_in">number</span>(browserId).<span class="built_in">toStdString</span>());</span><br><span class="line">    args-&gt;<span class="built_in">SetString</span>(idx++, QString::<span class="built_in">number</span>(frameId).<span class="built_in">toStdString</span>());</span><br><span class="line">    args-&gt;<span class="built_in">SetString</span>(idx++, m_metaMethod.className.<span class="built_in">toStdWString</span>());</span><br><span class="line">    args-&gt;<span class="built_in">SetString</span>(idx++, name);</span><br><span class="line">    args-&gt;<span class="built_in">SetString</span>(idx++, m_metaMethod.signature.<span class="built_in">toStdWString</span>());</span><br><span class="line">    <span class="comment">//check param count</span></span><br><span class="line">    QStringList signatureList;</span><br><span class="line">    QString callbackSignatures;</span><br><span class="line">    <span class="type">int</span> iSigIndex = idx;</span><br><span class="line">    args-&gt;<span class="built_in">SetString</span>(idx++, callbackSignatures.<span class="built_in">toStdWString</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化参数列表，根据不同的参数类型分别处理</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arguments.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsBool</span>()) &#123;</span><br><span class="line">            args-&gt;<span class="built_in">SetBool</span>(idx++, arguments[i]-&gt;<span class="built_in">GetBoolValue</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsInt</span>()) &#123;</span><br><span class="line">            args-&gt;<span class="built_in">SetInt</span>(idx++, arguments[i]-&gt;<span class="built_in">GetIntValue</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsDouble</span>()) &#123;</span><br><span class="line">            <span class="type">double</span> dValue = arguments[i]-&gt;<span class="built_in">GetDoubleValue</span>();</span><br><span class="line">            <span class="comment">//如果double值为NAN，报错</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isnan</span>(dValue)) &#123;</span><br><span class="line">                exception = <span class="built_in">QString</span>(<span class="string">u8&quot;argument %1 is nan !&quot;</span>).<span class="built_in">arg</span>(i).<span class="built_in">toStdWString</span>();</span><br><span class="line">                retval = CefV8Value::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            args-&gt;<span class="built_in">SetDouble</span>(idx++, dValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsString</span>()) &#123;</span><br><span class="line">            args-&gt;<span class="built_in">SetString</span>(idx++, arguments[i]-&gt;<span class="built_in">GetStringValue</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsFunction</span>()) &#123;</span><br><span class="line">            <span class="comment">//参数类型为函数，生成回调函数签名</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            args-&gt;<span class="built_in">SetNull</span>(idx++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理带返回值的同步调用，略</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 发送IPC消息，尝试读取返回值，异步调用返回undefined</span></span><br><span class="line">    <span class="keyword">if</span> (m_browser &amp;&amp; m_frame) &#123;</span><br><span class="line">        m_frame-&gt;<span class="built_in">SendProcessMessage</span>(PID_BROWSER, msg);</span><br><span class="line">        retval = <span class="built_in">readSynchronizeValue</span>(retTypeSignature, m_metaMethod.retType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = CefV8Value::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-browser进程收到调用请求后的处理"><a href="#7-browser进程收到调用请求后的处理" class="headerlink" title="7. browser进程收到调用请求后的处理"></a>7. browser进程收到调用请求后的处理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefBrowserHandlerBase::DispatchNotifyRequest</span><span class="params">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class="line"><span class="params"><span class="function">    CefProcessId source_process,</span></span></span><br><span class="line"><span class="params"><span class="function">    CefRefPtr&lt;CefProcessMessage&gt; message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CefString messageName = message-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">    CefRefPtr&lt;CefListValue&gt; messageArguments = message-&gt;<span class="built_in">GetArgumentList</span>();</span><br><span class="line">    <span class="keyword">if</span> (!messageArguments)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> browserId = browser-&gt;<span class="built_in">GetIdentifier</span>();</span><br><span class="line">    <span class="keyword">if</span> (messageName == QCEF_INVOKENGLMETHOD) &#123;</span><br><span class="line">        QVariantList varList;</span><br><span class="line">        <span class="comment">//遍历参数，将CEF参数列表转换为QVariantList</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; messageArguments-&gt;<span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (QVariant::Type::String != varList[idx].<span class="built_in">type</span>() ||</span><br><span class="line">            QVariant::Type::String != varList[idx + <span class="number">1</span>].<span class="built_in">type</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取browserId，判断是否需要处理此消息</span></span><br><span class="line">        <span class="comment">//browser和render是一对多的关系，当收到QCEF_INVOKENGLMETHOD消息时，需要根据browserId进行过滤，否则会重复调用</span></span><br><span class="line">        <span class="type">int</span> messageBrowserId = QString::<span class="built_in">fromStdString</span>(varList[idx++].<span class="built_in">toString</span>().<span class="built_in">toStdString</span>()).<span class="built_in">toInt</span>();</span><br><span class="line">        int64 frameId = QString::<span class="built_in">fromStdString</span>(varList[idx++].<span class="built_in">toString</span>().<span class="built_in">toStdString</span>()).<span class="built_in">toLongLong</span>();</span><br><span class="line">        <span class="keyword">if</span> (messageBrowserId != browserId)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行反射调用</span></span><br><span class="line">        QString strCallbackSignatures;</span><br><span class="line">        <span class="type">bool</span> bOk = QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">inovkeMethod</span>(browserId, varList, strCallbackSignatures);</span><br><span class="line">        <span class="comment">//调用失败，发送清理回调消息</span></span><br><span class="line">        <span class="keyword">if</span> (!bOk) &#123;</span><br><span class="line">            <span class="comment">//send clear callbacks</span></span><br><span class="line">            CefRefPtr&lt;CefProcessMessage&gt; msg = CefProcessMessage::<span class="built_in">Create</span>(QCEF_CLEARNGLCALLBACKS);</span><br><span class="line">            <span class="keyword">auto</span> paramValue = msg-&gt;<span class="built_in">GetArgumentList</span>();</span><br><span class="line">            <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            paramValue-&gt;<span class="built_in">SetString</span>(idx++, strCallbackSignatures.<span class="built_in">toStdWString</span>());</span><br><span class="line">            browser-&gt;<span class="built_in">GetMainFrame</span>()-&gt;<span class="built_in">SendProcessMessage</span>(CefProcessId::PID_RENDERER, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bOk;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-Qt反射调用"><a href="#8-Qt反射调用" class="headerlink" title="8 Qt反射调用"></a>8 Qt反射调用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefJavaScriptEngine::inovkeMethod</span><span class="params">(<span class="type">int</span> browserId, <span class="type">const</span> QVariantList&amp; messageArguments, QString&amp; callbackSignature)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> messageBrowserId = QString::<span class="built_in">fromStdString</span>(messageArguments[idx++].<span class="built_in">toString</span>().<span class="built_in">toStdString</span>()).<span class="built_in">toInt</span>();</span><br><span class="line">    qint64 frameId = QString::<span class="built_in">fromStdString</span>(messageArguments[idx++].<span class="built_in">toString</span>().<span class="built_in">toStdString</span>()).<span class="built_in">toLongLong</span>();</span><br><span class="line">    <span class="comment">//校验browserId</span></span><br><span class="line">    <span class="keyword">if</span> (messageBrowserId != browserId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验消息格式</span></span><br><span class="line">    <span class="comment">//browserId className method methodSignature</span></span><br><span class="line">    <span class="keyword">if</span> (QVariant::Type::String != messageArguments[idx].<span class="built_in">type</span>() ||</span><br><span class="line">        QVariant::Type::String != messageArguments[idx + <span class="number">1</span>].<span class="built_in">type</span>() ||</span><br><span class="line">        QVariant::Type::String != messageArguments[idx + <span class="number">2</span>].<span class="built_in">type</span>() ||</span><br><span class="line">        QVariant::Type::String != messageArguments[idx + <span class="number">3</span>].<span class="built_in">type</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据IPC消息中的类名获取元对象实例</span></span><br><span class="line">    <span class="keyword">if</span> (!m_registeredMetaObjectMap.<span class="built_in">contains</span>(className)) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;meta method for name: %s not found !&quot;</span>, <span class="built_in">qPrintable</span>(className));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> QMetaObject* metaObj = m_registeredMetaObjectMap[className];</span><br><span class="line">    <span class="comment">//校验元对象中是否存在此函数</span></span><br><span class="line">    <span class="type">int</span> iMethod = metaObj-&gt;<span class="built_in">indexOfMethod</span>(metaObj-&gt;<span class="built_in">normalizedSignature</span>(methodSignature.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>()).<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (iMethod == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;method %s index not found !&quot;</span>, <span class="built_in">qPrintable</span>(method));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取元函数信息，以此为基础准备反射调用参数，对JS传过来的参数做适当的转换</span></span><br><span class="line">    QMetaMethod metaMethod = m_registeredMetaObjectMap[className]-&gt;<span class="built_in">method</span>(iMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找注册对象实例，后续在此对象上执行反射调用</span></span><br><span class="line">    <span class="keyword">if</span> (!m_jsObjectBindingMap.<span class="built_in">contains</span>(className)) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;class name: %s not found !&quot;</span>, <span class="built_in">qPrintable</span>(className));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QObject* obj = m_jsObjectBindingMap[className];</span><br><span class="line">    <span class="type">bool</span> bNeedWrap = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//参数转换，会做类型兼容处理，如果参数数量不够则补齐，多余的参数则忽略</span></span><br><span class="line">    QVariantList varList;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; metaMethod.<span class="built_in">parameterCount</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> paramTypeId = metaMethod.<span class="built_in">parameterType</span>(i);</span><br><span class="line">        <span class="type">int</span> messageIndex = idx + i;</span><br><span class="line">        <span class="comment">//转换和准备反射调用参数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    QGenericReturnArgument retArg;</span><br><span class="line">    <span class="comment">//使用Qt的反射调用接口发起反射调用</span></span><br><span class="line">    bRet = QMetaObject::<span class="built_in">invokeMethod</span>(obj, <span class="built_in">qUtf8Printable</span>(method), Qt::DirectConnection, retArg, argList[<span class="number">0</span>],</span><br><span class="line">        argList[<span class="number">1</span>], argList[<span class="number">2</span>], argList[<span class="number">3</span>], argList[<span class="number">4</span>], argList[<span class="number">5</span>], argList[<span class="number">6</span>], argList[<span class="number">7</span>], argList[<span class="number">8</span>], argList[<span class="number">9</span>]);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-回调函数触发机制"><a href="#5-2-回调函数触发机制" class="headerlink" title="5.2 回调函数触发机制"></a>5.2 回调函数触发机制</h2><p>在CEF中，JavaScript函数多为异步调用，通过传递一个callback的方式接收异步调用结果。callback本身是一个V8内的Function对象，它仅在当前render进程上下文中有效，无法通过简单的序列化直接传递到browser进程中，最终callback的触发也是要落回到render进程，那我们应该怎么触发回调呢？<br>所以我们想到了一个经典的解决方案“句柄”。<br>在Win32编程中， <strong>句柄</strong> 的存在非常普遍，大量的Win32 API都使用它作为参数，如WriteFile, CloseHandle，WaitForSingleObject等。句柄其实是内核句柄表的一个标识，使用它可以引用一个内核资源。这样内核就在不暴露内部资源本身的情况下允许用户操作该资源。<br>我们借用这个思路，当一个JavaScript函数被执行时，将参数传入的Function对象记录下来，为该对象生成一个唯一的key，将key作为参数通过IPC发送到browser进程，browser进程在合适的时机通过这个key发送IPC消息给render进程来触发回调。</p>
<h3 id="1-Execute函数中对回调函数的处理"><a href="#1-Execute函数中对回调函数的处理" class="headerlink" title="1 Execute函数中对回调函数的处理"></a>1 Execute函数中对回调函数的处理</h3><p>生成signature，将对象以以signature为key保存起来，这里考虑到一个函数中可以接收多个回调，最后拼接的signature以;分隔。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefFunctionObject::Execute</span><span class="params">(<span class="type">const</span> CefString&amp; name, CefRefPtr&lt;CefV8Value&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CefV8ValueList&amp; arguments, CefRefPtr&lt;CefV8Value&gt;&amp; retval, CefString&amp; exception)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化参数列表，根据不同的参数类型分别处理</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arguments.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsBool</span>()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments[i]-&gt;<span class="built_in">IsFunction</span>()) &#123;</span><br><span class="line">            <span class="comment">//参数类型为函数，生成回调函数签名</span></span><br><span class="line">            QString strUuid;</span><br><span class="line">            strUuid = QUuid::<span class="built_in">createUuid</span>().<span class="built_in">toString</span>().<span class="built_in">toUpper</span>();</span><br><span class="line">            strUuid = strUuid.<span class="built_in">mid</span>(<span class="number">1</span>, strUuid.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">            strUuid = strUuid.<span class="built_in">replace</span>(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//生成格式为：browserId.frameId.className.methodName.index.uuid</span></span><br><span class="line">            QString callbackSig = <span class="built_in">QString</span>(<span class="string">&quot;%1.%2.%3.%4.%5.%6&quot;</span>).<span class="built_in">arg</span>(m_browser-&gt;<span class="built_in">GetIdentifier</span>()).<span class="built_in">arg</span>(frameId).<span class="built_in">arg</span>(m_metaMethod.className).<span class="built_in">arg</span>(m_metaMethod.name)</span><br><span class="line">                .<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(strUuid);</span><br><span class="line">            signatureList &lt;&lt; callbackSig;</span><br><span class="line">            <span class="comment">//保存当前的callback和contex</span></span><br><span class="line">            QCefFunctionCallback functionCallback;</span><br><span class="line">            functionCallback.callback = arguments[i];</span><br><span class="line">            functionCallback.context = CefV8Context::<span class="built_in">GetCurrentContext</span>();</span><br><span class="line">            <span class="comment">//以signature为key，插入到map中</span></span><br><span class="line">            CefString callbackSignature = callbackSig.<span class="built_in">toStdWString</span>();</span><br><span class="line">            m_callbacksMap.<span class="built_in">insert</span>(callbackSignature, functionCallback);</span><br><span class="line">            <span class="built_in">TRACED</span>(<span class="string">&quot;callback found at: %d, signature is: %s&quot;</span>, i, <span class="built_in">qPrintable</span>(callbackSig));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            args-&gt;<span class="built_in">SetNull</span>(idx++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理带返回值的同步调用，略</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 发送IPC消息，尝试读取返回值，异步调用返回undefined</span></span><br><span class="line">    <span class="keyword">if</span> (m_browser &amp;&amp; m_frame) &#123;</span><br><span class="line">        m_frame-&gt;<span class="built_in">SendProcessMessage</span>(PID_BROWSER, msg);</span><br><span class="line">        retval = <span class="built_in">readSynchronizeValue</span>(retTypeSignature, m_metaMethod.retType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = CefV8Value::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-browser进程IPC触发回调"><a href="#2-browser进程IPC触发回调" class="headerlink" title="2 browser进程IPC触发回调"></a>2 browser进程IPC触发回调</h3><p>browser进程中，当函数执行结束后，拼接IPC消息发送给render进程用来触发回调</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefCoreBrowserBase::invokeJavaScriptCallback</span><span class="params">(qint64 frameId, <span class="type">const</span> QString&amp; jsCallbackSignature, QVariantList params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_browser)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CefRefPtr&lt;CefProcessMessage&gt; msg = CefProcessMessage::<span class="built_in">Create</span>(QCEF_INVOKENGLCALLBACK);</span><br><span class="line">    <span class="keyword">auto</span> paramValue = msg-&gt;<span class="built_in">GetArgumentList</span>();</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    paramValue-&gt;<span class="built_in">SetString</span>(idx++, jsCallbackSignature.<span class="built_in">toStdWString</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : params) &#123;</span><br><span class="line">        QVariant::Type vType = value.<span class="built_in">type</span>();</span><br><span class="line">        <span class="keyword">if</span> (vType == QVariant::Type::String) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            paramValue-&gt;<span class="built_in">SetNull</span>(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CefRefPtr&lt;CefFrame&gt; frame = _browser-&gt;<span class="built_in">GetFrame</span>(frameId);</span><br><span class="line">    <span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;browserId: %d get frame by frameId: %ld failed !&quot;</span>, <span class="built_in">getBrowserId</span>(), frameId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    frame-&gt;<span class="built_in">SendProcessMessage</span>(CefProcessId::PID_RENDERER, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-render进程响应代码"><a href="#3-render进程响应代码" class="headerlink" title="3 render进程响应代码"></a>3 render进程响应代码</h3><p>render进程收到回调触发的IPC消息后，通过signatur中的信息查找到对应的回调函数并触发该回调</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RenderDelegate::OnTriggerEventNotifyMessage</span><span class="params">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class="line"><span class="params"><span class="function">            CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class="line"><span class="params"><span class="function">            CefProcessId source_process,</span></span></span><br><span class="line"><span class="params"><span class="function">            CefRefPtr&lt;CefProcessMessage&gt; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">TRACET</span>();</span><br><span class="line">        CefString messageName = message-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">        <span class="keyword">if</span> (messageName == QCEF_INVOKENGLCALLBACK) &#123;</span><br><span class="line">            CefRefPtr&lt;CefListValue&gt; messageArguments = message-&gt;<span class="built_in">GetArgumentList</span>();</span><br><span class="line">            ...</span><br><span class="line">            strSignature = QString::<span class="built_in">fromStdWString</span>(messageArguments-&gt;<span class="built_in">GetString</span>(idx++).<span class="built_in">ToWString</span>());</span><br><span class="line">            <span class="keyword">auto</span> sigList = strSignature.<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">int</span> browserId = sigList[<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">            int64 frameId = sigList[<span class="number">1</span>].<span class="built_in">toLongLong</span>();</span><br><span class="line">            <span class="comment">//not the same browser, return it.</span></span><br><span class="line">            <span class="keyword">if</span> (browserId != browser-&gt;<span class="built_in">GetIdentifier</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            CefRefPtr&lt;CefListValue&gt; newArguments = CefListValue::<span class="built_in">Create</span>();</span><br><span class="line">            <span class="type">int</span> iNewIdx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//准备回调函数的参数</span></span><br><span class="line">            <span class="keyword">for</span> (idx; idx &lt; messageArguments-&gt;<span class="built_in">GetSize</span>(); idx++) &#123;</span><br><span class="line">                newArguments-&gt;<span class="built_in">SetValue</span>(iNewIdx++, messageArguments-&gt;<span class="built_in">GetValue</span>(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = frame_id_to_client_map_.<span class="built_in">find</span>(frameId);</span><br><span class="line">            <span class="keyword">if</span> (it != frame_id_to_client_map_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                it-&gt;second-&gt;<span class="built_in">invokeCallBack</span>(strSignature, newArguments);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">TRACEE</span>(<span class="string">&quot;QCEF_INVOKENGLCALLBACK can&#x27;t find QCefClient by id: %ld&quot;</span>, frameId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageName == QCEF_CLEARNGLCALLBACKS) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-执行回调"><a href="#4-执行回调" class="headerlink" title="4. 执行回调"></a>4. 执行回调</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefJavaScriptEnvironment::invokeCallBack</span><span class="params">(<span class="type">const</span> QString&amp; signature, CefRefPtr&lt;CefListValue&gt; argumentList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TRACED</span>(<span class="string">&quot;signature is: %s&quot;</span>, <span class="built_in">qPrintable</span>(signature));</span><br><span class="line">    <span class="keyword">auto</span> sigList = signature.<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sigList.<span class="built_in">size</span>() != SIGNATURE_VALID_PARTS_COUNT)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> browserId = sigList[<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="type">int</span> frameId = sigList[<span class="number">1</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="type">const</span> QString&amp; className = sigList[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> QString&amp; method = sigList[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//根据className查找JavaScript对象</span></span><br><span class="line">    <span class="keyword">if</span> (!m_javaScriptObjectMap.<span class="built_in">contains</span>(className)) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;js object map not found %s&quot;</span>, <span class="built_in">qPrintable</span>(className));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QPair&lt;CefRefPtr&lt;QCefJavaScriptObject&gt;, CefRefPtr&lt;CefV8Value&gt;&gt; jsObjectPair = m_javaScriptObjectMap[className];</span><br><span class="line">    <span class="keyword">if</span> (!jsObjectPair.first || !jsObjectPair.second) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;%s: jsObjectPair invalid !&quot;</span>, <span class="built_in">qPrintable</span>(className));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据函数名查找函数对象</span></span><br><span class="line">    CefRefPtr&lt;QCefFunctionObject&gt; functionObj = jsObjectPair.first-&gt;<span class="built_in">getFunction</span>(method);</span><br><span class="line">    <span class="keyword">if</span> (!functionObj) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;get functionObj failed !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CefRefPtr&lt;CefV8Value&gt; retVal;</span><br><span class="line">    CefString exception;</span><br><span class="line">    <span class="comment">//触发回调</span></span><br><span class="line">    <span class="type">bool</span> bRet = functionObj-&gt;<span class="built_in">ExecuteCallback</span>(signature.<span class="built_in">toStdWString</span>(), jsObjectPair.second, argumentList, retVal, exception);</span><br><span class="line">    <span class="keyword">if</span> (bRet)</span><br><span class="line">        <span class="built_in">TRACED</span>(<span class="string">&quot;execute callback using signature: %s success !&quot;</span>, <span class="built_in">qPrintable</span>(signature));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;execute callback using signature: %s failed !!!&quot;</span>, <span class="built_in">qPrintable</span>(signature));</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCefFunctionObject::ExecuteCallback</span><span class="params">(<span class="type">const</span> CefString&amp; signature, CefRefPtr&lt;CefV8Value&gt; object, CefRefPtr&lt;CefListValue&gt; arguments, CefRefPtr&lt;CefV8Value&gt;&amp; retval, CefString&amp; exception)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断当前callback是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!m_callbacksMap.<span class="built_in">contains</span>(signature)) &#123;</span><br><span class="line">        exception = <span class="string">&quot;can&#x27;t get callback !&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取之前保存的callback结构，切换context</span></span><br><span class="line">    QCefFunctionCallback funcCallback = m_callbacksMap[signature];</span><br><span class="line">    <span class="keyword">if</span> (!funcCallback.context-&gt;<span class="built_in">Enter</span>()) &#123;</span><br><span class="line">        exception = <span class="string">L&quot;enter current context error !&quot;</span>;</span><br><span class="line">        retval = CefV8Value::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">CefV8ValueList <span class="title">v8Arguments</span><span class="params">(arguments-&gt;GetSize())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (arguments) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arguments-&gt;<span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">//参数转换</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用CEF标准接口触发函数执行 CefV8Value::ExecuteFunction</span></span><br><span class="line">    retval = funcCallback.callback-&gt;<span class="built_in">ExecuteFunction</span>(object, v8Arguments);</span><br><span class="line">    <span class="comment">//退出上下文环境</span></span><br><span class="line">    <span class="keyword">if</span> (!funcCallback.context-&gt;<span class="built_in">Exit</span>()) &#123;</span><br><span class="line">        exception = <span class="string">L&quot;exit current context error !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-回调资源的管理"><a href="#5-3-回调资源的管理" class="headerlink" title="5.3 回调资源的管理"></a>5.3 回调资源的管理</h2><p>当我们使用句柄的时候，记得一定要调用CloseHandle关闭打开的句柄资源，否则会导致句柄泄露。回顾我们对回调函数的处理过程，回调函数也需要在合适的实际被释放，否则同样会造成泄露。CEF内部对象统一使用引用计数来管理，我们将回调保存在map中会导致该对象无法释放，这样是存在问题的。<br>那思考这样一个问题：<strong>一个JavaScript回调函数的生命周期是怎样的？</strong><br>一个简单的思路是，回调函数执行完之后立即销毁回调对象，这样我们可以保证回调函数最终会被释放。 但是这样做是否恰当？当函数执行结束后，回调函数是否还可能继续存在？<br>在Launcher中存在这样一个接口调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nts.<span class="property">stub</span>.<span class="title function_">setCallback</span>(callback);</span><br></pre></td></tr></table></figure>
<p>这里要求web端注册一个回调，当stub的通知消息到达时，此回调会被触发，将通知消息透传给web。这时注册进去的callback更类似一个全局变量，可以被重复触发。<br>所以实际的情况是，回调函数在调用结束后，可能会继续存在，也可能被销毁，这个要看具体的业务需求，而业务存在于browser进程。<br>所以回调函数的释放时机：</p>
<ol>
<li>函数执行完之后自动释放</li>
<li><strong>由browser进程决定何时释放</strong></li>
</ol>
<p>我们选方案2</p>
<p>简单的思路，添加一种专门用于释放回调函数的IPC消息，在恰当的时机发送给render进程，专门用来释放回调资源。但是这样存在一个问题，如果使用者忘了发送清理消息，callback仍然会泄露。本着<strong>避免使用者出错</strong>的原则，我们不希望用户关心释放的细节，这里使用C++的RAII对回调函数进行管理。</p>
<blockquote>
<p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）,也称为“资源获取就是初始化”，是C++语言的一种管理资源、避免泄漏的惯用法。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。简单的说，RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。</p>
</blockquote>
<p>我们将callback的signature放如callBack对象中进行管理，通过引用计数来管理此对象的生命周期，直到不存在指针指向此对象，则销毁它，析构函数中发送释放回调函数的消息，从render进程中清理掉此回调。</p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QCEFCORE_EXPORT</span> JavaScriptCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JavaScriptCallback</span>(<span class="type">const</span> QString&amp; signature, <span class="keyword">class</span> QCefCoreManagerBase* coreManager);</span><br><span class="line">    <span class="built_in">JavaScriptCallback</span>();</span><br><span class="line">    ~<span class="built_in">JavaScriptCallback</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trigger</span><span class="params">(<span class="type">const</span> QVariantList&amp; vars)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBrowserId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">qint64 <span class="title">getFrameId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QString m_callbackSignature;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现代码</span></span><br><span class="line">JavaScriptCallback::~<span class="built_in">JavaScriptCallback</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_callbackSignature.<span class="built_in">isEmpty</span>() || !m_coreManager)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_coreManager-&gt;<span class="built_in">clearJavaScriptCallback</span>(m_callbackSignature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JavaScriptCallback::isValid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !m_callbackSignature.<span class="built_in">isEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JavaScriptCallback::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_callbackSignature.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JavaScriptCallback::trigger</span><span class="params">(<span class="type">const</span> QVariantList&amp; vars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_callbackSignature.<span class="built_in">isEmpty</span>() || !m_coreManager)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_coreManager-&gt;<span class="built_in">invokeJavaScriptCallback</span>(m_callbackSignature, vars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为回调函数可能存在多个，所以我们构造了一个JavaScriptCallbacksCollection对象用来管理这些回调函数，它会接收形如：sig1;sig2;sig3;的字符串，拆分并依次构造回调对象，保存在内部的对象列表中。此对象是每一个C++导出函数的第一个参数，下面的绑定示例代码中演示了此对象的使用。当通过反射调用时，此对象会被构造并传递给C++函数。</p>
<h2 id="5-4-简单使用"><a href="#5-4-简单使用" class="headerlink" title="5.4 简单使用"></a>5.4 简单使用</h2><p>自动绑定层实现完成之后，使用是非常方便的，仅需要定义要导出的接口，然后注册即可，新增接口时直接添加新的C++函数，无需其它繁琐步骤即可自动注到JavaScript中。</p>
<h3 id="1-定义QObject的子类，通过Qt宏将要导出的C-接口定义为槽函数"><a href="#1-定义QObject的子类，通过Qt宏将要导出的C-接口定义为槽函数" class="headerlink" title="1 定义QObject的子类，通过Qt宏将要导出的C++接口定义为槽函数"></a>1 定义QObject的子类，通过Qt宏将要导出的C++接口定义为槽函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JSObjectBase</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JSObjectBase</span>(QObject* parent);</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.getWebId——获取窗口的ID</span></span><br><span class="line"><span class="comment">    function signature	nts.base.getWebId(ResultCallback callback)</span></span><br><span class="line"><span class="comment">    parameters	参数名	参数类型	参数说明</span></span><br><span class="line"><span class="comment">    callback</span></span><br><span class="line"><span class="comment">    response	参数名	参数类型	参数说明</span></span><br><span class="line"><span class="comment">        id	string	该页面的唯一标识</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getWebId</span><span class="params">(<span class="type">const</span> JavaScriptCallbacksCollection&amp; cbCollection)</span></span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JSObjectBase::getWebId</span><span class="params">(<span class="type">const</span> JavaScriptCallbacksCollection&amp; cbCollections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取第一个回调函数</span></span><br><span class="line">    JavaScriptGetDataCallbackPtr cb = cbCollections.<span class="built_in">get</span>&lt;JavaScriptGetDataCallback&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取此回调对应的browserId</span></span><br><span class="line">    <span class="type">int</span> browserId = cb-&gt;<span class="built_in">getBrowserId</span>();</span><br><span class="line">    <span class="comment">//根据browserId获取webId</span></span><br><span class="line">    <span class="type">const</span> QString&amp; webId = NglLauncher::<span class="built_in">get</span>()-&gt;<span class="built_in">getMainWindow</span>()-&gt;<span class="built_in">getWebId</span>(browserId);</span><br><span class="line">    <span class="comment">//拼接返回json，发送IPC消息触发回调</span></span><br><span class="line">    cb-&gt;<span class="built_in">execute</span>(ResultStatus_Success, <span class="built_in">JsonBuilder</span>().<span class="built_in">add</span>(<span class="string">&quot;id&quot;</span>, webId).<span class="built_in">build</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//cb对象销毁，发送清理消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-注册Qt对象"><a href="#2-注册Qt对象" class="headerlink" title="2 注册Qt对象"></a>2 注册Qt对象</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">JavaScriptEngine::init</span><span class="params">(<span class="type">const</span> QString&amp; contextId, <span class="type">const</span> QString&amp; version, <span class="type">int</span> versionCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bOk = QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span> (!bOk) &#123;</span><br><span class="line">        <span class="built_in">TRACEE</span>(<span class="string">&quot;QCefJavaScriptEngine init failed !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;base&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectBase</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;login&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectLogin</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;game&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectGame</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;system&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectSystem</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;system.os&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectOs</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;system.disk&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectDisk</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;system.memory&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectMemory</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;system.cpu&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectCPU</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;system.videoCard&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectVideoCard</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;stub&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectStub</span>(<span class="keyword">this</span>));</span><br><span class="line">    QCefJavaScriptEngine::<span class="built_in">get</span>()-&gt;<span class="built_in">registerObject</span>(<span class="string">&quot;ngl&quot;</span>, <span class="keyword">new</span> <span class="built_in">JSObjectNgl</span>(contextId, version, versionCode, <span class="keyword">this</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p><img src="/2020/11/27/%E9%87%8D%E6%9E%84%E7%89%88Launcher%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%9ACEF%E7%AF%87/IMG_2020-11-30-09-47-26.png"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>CEF</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CEF</tag>
      </tags>
  </entry>
  <entry>
    <title>跳转，执行，返回：从汇编看函数调用</title>
    <url>/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>从本篇开始，我们讨论一些高级语言中的基础设施：堆栈，函数调用，变量生命周期等等话题。因为这里本身会涉及到比较多的汇编层面的基础概念。为了向大家说明汇编层的函数调用实现细节，无奈我只能罗列出很多汇编上的概念，因为本文假定读者不需要具有任何汇编知识。我讨厌长篇大论，但本篇的解释可能仍然不够明晰。在此为自己知识的浅薄表示歉意。</p>
<span id="more"></span>

<h1 id="从代码的顺序执行说起"><a href="#从代码的顺序执行说起" class="headerlink" title="从代码的顺序执行说起"></a>从代码的顺序执行说起</h1><p>每一个程序员脑子里应该都有这么一种印象：“程序是顺序执行的”。这个观点其实和我们开篇所讲的cpu的流水线执行过程直接相关。<br>让我们再回忆一下脑海中关于函数调用的概念，也许会是这个样子：</p>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-27-43.png"><br>这里的“控制流转移”又是如何发生的呢？在解释这个之前，也许我们需要科普一点有关于汇编的知识。</p>
<h1 id="函数调用中的一些细节说明"><a href="#函数调用中的一些细节说明" class="headerlink" title="函数调用中的一些细节说明"></a>函数调用中的一些细节说明</h1><h2 id="函数调用中的关键寄存器"><a href="#函数调用中的关键寄存器" class="headerlink" title="函数调用中的关键寄存器"></a>函数调用中的关键寄存器</h2><h3 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h3><p>程序计数器是一个计算机组成原理中讲过的概念，下面给出一个百度百科中的简单解释</p>
<p>程序计数器是用于存放下一条指令所在单元的地址的地方。<br>当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>
<p>可以看到，程序计数器是一个cpu执行指令代码过程中的关键寄存器：它指向了当前计算机要执行的指令地址，CPU总是从程序计数器取出当前指令来执行。当指令执行后，程序计数器的值自动增加，指向下一条将要执行的指令。</p>
<p>在x86汇编中，执行程序计数器功能的寄存器被叫做EIP，也叫作指令指针寄存器。</p>
<h3 id="基址指针，栈指针和程序栈"><a href="#基址指针，栈指针和程序栈" class="headerlink" title="基址指针，栈指针和程序栈"></a>基址指针，栈指针和程序栈</h3><p>栈是程序设计中的一种经典数据结构，每个程序都拥有自己的程序栈。很重要的一点是，栈是向下生长的。所谓向下生长是指从内存高地址-&gt;低地址的路径延伸，那么就很明显了，栈有栈底和栈顶，那么栈顶的地址要比栈底低。对x86体系的CPU而言，其中<br>—&gt; 寄存器ebp（base pointer ）可称为“帧指针”或“基址指针”，其实语意是相同的。<br>—&gt; 寄存器esp（stack pointer）可称为“ 栈指针”。<br>在C和C++语言中，临时变量分配在栈中，临时变量拥有函数级的生命周期，即“在当前函数中有效，在函数外无效”。这种现象就是函数调用过程中的参数压栈，堆栈平衡所带来的。对于这种实现的细节，我们会在接下来的环节中详细讨论。</p>
<h2 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h2><p>堆栈平衡这个概念指的是函数调完成后，要返还所有使用过的栈空间。这种说法可能有点抽象，我们可以举一个简单的例子来类比：<br>我们都知道函数的临时变量存放在栈中。那我们来看下面的代码，它是一个很简单的函数,用来交换传入的2个参数的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> c = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在这个函数中使用了一个临时变量int c;这个变量分配在栈中，我们可以简单的理解为，在声明临时变量c后，我们就向当前的程序栈中压入了一个int值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c = a; &lt;==&gt; <span class="built_in">push</span>(a);   <span class="comment">//简单粗暴，临时变量的声明理解为简单地向栈中push一个值。</span></span><br></pre></td></tr></table></figure>
<p>那现在这个函数swap调用结束了，我们是否需要退栈，把之前临时变量c使用的栈空间返还回去？需要吗？不需要吗？<br>我们假设不需要，当我们频繁调用swap的时候，会发生什么？每次调用，程序栈都在 <strong>生长</strong>。直到栈满，我们就会收到<strong>stack overflow</strong>错误，程序挂掉了。<br>所以为了避免这种乌龙的事情发生，我们需要在函数调用结束后，退栈，把堆栈还原到函数调用前的状态，这些被pop掉的临时变量，自然也就失效了，这也解释了我们一直以来关于<strong>临时变量仅在当前函数内有效</strong>的认知。其实堆栈平衡这个概念本身比这种粗浅的理解要复杂的多，还应包括压栈参数的平衡，暂时我们可以简单地这样理解，后面再做详细说明。</p>
<h2 id="函数的参数传递和调用约定"><a href="#函数的参数传递和调用约定" class="headerlink" title="函数的参数传递和调用约定"></a>函数的参数传递和调用约定</h2><p>函数的参数传递是一个参数压栈的过程。函数的所有参数，都会依次被push到栈中。那调用约定有是什么呢？<br>C和C++程序员应该对所谓的调用约定有一定的印象，就像下面这种代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的__stdcall就是关于调用约定的声明。其中标准C函数的默认调用约定是__stdcall,C++全局函数和静态成员函数的默认调用约定是__cdecl，类的成员函数的调用约定是__thiscall。剩下的还有__fastcall，__naked等。</p>
<p>为什么要用所谓的<strong>调用约定</strong>？调用约定其实是一种约定方式，它指明了函数调用中的参数传递方式和堆栈平衡方式。</p>
<h3 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h3><p>还是之前那个例子，swap函数有2个参数，int a,int b。这两个参数，入栈的顺序谁先谁后？<br>其实是从左到右入栈还是从右到左入栈都可以，只要函数调用者和函数内部使用相同的顺序存取参数即可。在上述的所有调用约定中，参数总是从右到左压栈，也就是最后一个参数先入栈。我们可以使用一份伪代码描述这个过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push b;      //先压入参数b</span><br><span class="line">push a;      //再压入参数a</span><br><span class="line">call swap;  //调用swap函数</span><br></pre></td></tr></table></figure>
<p>其实从这里我们就可以理解为什么在函数内部，不能改变函数外部参数的值：因为函数内部访问到的参数其实是压入栈的变量值，对它的修改只是修改了栈中的”副本”。指针和引用参数才能真正地改变外部变量的值。</p>
<h3 id="堆栈平衡方式"><a href="#堆栈平衡方式" class="headerlink" title="堆栈平衡方式"></a>堆栈平衡方式</h3><p>因为函数调用过程中，参数需要压栈，所以在函数调用结束后，用于函数调用的压栈参数也需要退栈。那这个工作是交给调用者完成，还是在函数内部自己完成？其实两种都可以。调用者负责平衡堆栈的主要好处是可以实现可变参数（关于可变参数的话题，在此不做过多讨论。如果可能的话，我们可以以一篇单独的文章来讲这个问题），因为在参数可变的情况下，只有调用者才知道具体的压栈参数有几个。<br>下面列出了常见调用约定的堆栈平衡方式：</p>
<table>
<thead>
<tr>
<th>调用约定</th>
<th>堆栈平衡方式</th>
</tr>
</thead>
<tbody><tr>
<td>__stdcall</td>
<td>函数自己平衡</td>
</tr>
<tr>
<td>__cdecl</td>
<td>调用者负责平衡</td>
</tr>
<tr>
<td>__thiscall</td>
<td>调用者负责平衡</td>
</tr>
<tr>
<td>__fastcall</td>
<td>调用者负责平衡</td>
</tr>
<tr>
<td>__naked</td>
<td>编译器不负责平衡，由编写者自己负责</td>
</tr>
</tbody></table>
<h2 id="栈帧的概念：从esp和ebp说起"><a href="#栈帧的概念：从esp和ebp说起" class="headerlink" title="栈帧的概念：从esp和ebp说起"></a>栈帧的概念：从esp和ebp说起</h2><p>为什么我们需要ebp和esp2个寄存器来访问栈？这种观念其实来自于函数的层级调用：函数A调用函数B，函数B调用函数C，函数C调用函数D…<br>这种调用可能会涉及非常多的层次。编译器需要保证在这种复杂的嵌套调用中，能够正确地处理每个函数调用的堆栈平衡。所以我们引入了2个寄存器：</p>
<ol>
<li><p>ebp指向了本次函数调用开始时的栈顶指针，它也是本次函数调用时的“栈底”（这里的意思是，在一次函数调用中，ebp向下是函数的临时变量使用的空间）。在函数调用开始时，我们会使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ebp,esp </span><br></pre></td></tr></table></figure>
<p>把当前的esp保存在ebp中。</p>
</li>
<li><p>esp，它指向当前的栈顶，它是动态变化的，随着我们申请更多的临时变量，esp值不断减小（正如前文所说，栈是向下生长的）。</p>
</li>
<li><p>函数调用结束，我们使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esp,ebp</span><br></pre></td></tr></table></figure>
<p>来还原之前保存的esp。<br>在函数调用过程中，ebp和esp之间的空间被称为本次函数调用的“栈帧”。函数调用结束后，处于栈帧之前的所有内容都是本次函数调用过程中分配的临时变量，都需要被“返还”。这样在概念上，给了函数调用一个更明显的分界。下图是一个程序运行的某一时刻的栈帧图：</p>
</li>
</ol>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_Paste_Image.png.png"></p>
<h1 id="汇编中关于“函数调用”的实现"><a href="#汇编中关于“函数调用”的实现" class="headerlink" title="汇编中关于“函数调用”的实现"></a>汇编中关于“函数调用”的实现</h1><p>上面铺陈了很多的汇编层面的概念后，我们终于可以切回到我们本次的主题：函数调用。<br>函数调用其实可以看做4个过程，也就是本篇标题：</p>
<ol>
<li>压栈: 函数参数压栈，返回地址压栈</li>
<li>跳转: 跳转到函数所在代码处执行</li>
<li>执行: 执行函数代码</li>
<li>返回: 平衡堆栈，找出之前的返回地址，跳转回之前的调用点之后，完成函数调用<h2 id="call指令-压栈和跳转"><a href="#call指令-压栈和跳转" class="headerlink" title="call指令 压栈和跳转"></a>call指令 压栈和跳转</h2>下面我们看一下函数调用指令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x210000 call swap;</span><br><span class="line">0x210005 mov ecx,eax; </span><br></pre></td></tr></table></figure>
<p>我们可以把它理解为2个指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x210005;</span><br><span class="line">jmp swap;</span><br></pre></td></tr></table></figure>
<p>也就是，首先把call指令的下一条指令地址作为本次函数调用的返回地址压栈，然后使用jmp指令<strong>修改指令指针寄存器EIP</strong>，使cpu执行swap函数的指令代码。</p>
<h2 id="ret指令-返回"><a href="#ret指令-返回" class="headerlink" title="ret指令 返回"></a>ret指令 返回</h2><p>汇编中有ret相关的指令，它表示取出当前栈顶值，作为返回地址，并将指令指针寄存器EIP修改为该值，实现函数返回。<br>下面给出一组示意图来演示函数的返回过程：</p>
<ol>
<li>当前EIP的值为0x210004，指向指令ret 4，程序需要返回</li>
</ol>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-38-52.png"></p>
<ol start="2">
<li>执行ret指令，将当前esp指向的堆栈值当做返回地址，设置eip跳转到此处并弹出该值<br><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-39-04.png"></li>
</ol>
<p>经过这两步，函数就返回到了调用处。</p>
<h1 id="从实际汇编代码看函数调用"><a href="#从实际汇编代码看函数调用" class="headerlink" title="从实际汇编代码看函数调用"></a>从实际汇编代码看函数调用</h1><h2 id="程序源码和运行结果"><a href="#程序源码和运行结果" class="headerlink" title="程序源码和运行结果"></a>程序源码和运行结果</h2><p>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before swap: a = %d, b = %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after swap: a = %d, b = %d\r\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-40-10.png"><br>4.2 反汇编<br><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-40-21.png"><br><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-40-57.png"></p>
<p>可以看到，在函数调用前，函数参数已被压栈，此时:</p>
<blockquote>
<p>EBP = 00AFFCAC<br>ESP = 00AFFBBC<br>EIP = 00BF1853</p>
</blockquote>
<p>我们按F11，进入函数内部，此时：<br><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-41-33.png"><br>其实就是call swap指令的下一条指令地址，它就是本次函数调用的<strong>返回地址</strong>。<br><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-42-32.png"><br>下面是一个swap函数的详细注释：</p>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-42-40.png"><br>当程序运行到ret 8时</p>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-42-56.png"><br>执行返回后：<br><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-44-51.png"></p>
<p>在返回前，ESP = 00AFFBB8，返回后 ESP = 00AFFBC4<br>0x00AFFBC4 - 0x00AFFBB8 = 0xC<br>这里的数值是字节数，而我们知道，int是4字节长度。所以0xC/4 = 3<br>正好是2个压栈参数+一个返回地址。</p>
<h2 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h2><p>调试程序的时候，我们经常关注的一个点就是VisualStudio显示给我们的“调用堆栈”功能，这次让我们来仔细看一下它：<br>我们重新执行一次程序，这次我们关注一下vs显示的调用堆栈，如下图</p>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-45-50.png"></p>
<p>第一行是当前指令地址<br>第二行是外层调用者，我们双击它，跳转到如下地址：</p>
<p><img src="/2017/06/21/%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/IMG_2022-03-21-10-45-58.png"><br>也许这也是为什么这个功能被叫做“调用堆栈”的原因：它正是通过对程序栈的分析实现的。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>虽然我刻意压缩了很多的内容，但是为了把函数调用在汇编层面的实现问题解释清楚，本篇文章仍然很长。因为有太多的汇编前置知识需要解释，而我有不想脱离这个话题单独去谈论汇编，这样没有什么意义。<br>本篇作为追根溯源 从C++到汇编系列文章的第一篇“干货”，希望大家喜欢。写了这么多，难免有所疏漏，欢迎大家批评指正。<br>当然，作为一篇介绍性的文章，内容难免有所删减。比如，本文没有对ret n这种平衡方式做详细解释，也没有对各种汇编代码的含义做解释，还有引用参数的压栈方式，各种调用约定的具体使用情况和区别。当然，限于篇幅，有些东西无法面面俱到。但还是希望大家能够喜欢本篇文章。<br>你的鼓励，就是我最大的动力。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8?fr=aladdin">百度百科-程序计数器</a><br><a href="https://blog.csdn.net/zsy2020314/article/details/9429707">c函数调用过程原理及函数栈帧分析</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>asm</tag>
      </tags>
  </entry>
</search>
