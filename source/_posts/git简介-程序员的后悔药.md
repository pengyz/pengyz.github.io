---
title: 'git简介-程序员的后悔药'
date: 2017-06-11 17:56:19
updated: 2017-06-11 17:56:19

tags:
- git
categories:
- git
---


# 从软件开发谈“后悔药”的必要性

每当我们作出一个决定，我们就必然要承担它带来的后果。很多时候，面对未来的不确定性，我们会作出错误的决定。这时我们往往追悔莫及。但是这个世界上却永远不存在“后悔药”。就目前的科技水平来看，我们无力操纵时空，篡改历史。

万幸的是，作为程序员，我们却有工具来在软件开发的过程中随时给自己安利一发“后悔药”尝尝咸淡。这种后悔药叫做“版本控制”。

<!-- more -->

自计算机发明以来，IT这个行业乘着web，移动互联网的东风，开始了高速的发展：各种技术，框架，解决方案层出不穷。随着计算机的性能越来越强，人们有了越来越大的野心，希望借助计算机完成更多的工作，服务于现实生活。这种野望带来了软件规模的急剧膨胀。程序员面对这越来越复杂的情況，开始进入了大规模的协作开发阶段。这时候摆在人们面前的问题有很多，比如：

1. 怎样才能顺利的协作？我改的函数别人也改过，怎么才能把大家的修改合并在一起？
2. 某个版本出现问题，如何能够方便地进行版本回滚以挽救自己的饭碗？
3. 代码写到一半的时候老大通知线上的bug需要紧急修复，自己这里写到一半的代码还跑不起来，how to play?
4. 我们发布了1.0版本，然后发布了2.0版本，测试发现2.0版本存在某个bug而1.0版本却没有，怎么才能快速排查并定位问题？

这些情况都要求我们能够有效地管理程序的各种版本，形成一个可以回溯的版本历史记录，以便我们可以通过对版本历史的回溯操作来达到自如切换的目的。

也许你听说过svn，但是我们今天要介绍的却是版本控制工具里的"大杀器": git

git被证明是目前版本控制工具里的最佳实践。它的设计者是大名鼎鼎的顶级黑客**linus torvalds**，linux内核的原作者，linux开源社区的领导者。linus以一个文件系统设计者的思维高度设计了分布式版本控制工具git，其先进的设计理念让这个工具迅速风靡，可以说拯救了无数程序员的饭碗。

正所谓前人栽树后人乘凉，在此感谢linus大神间接地赏了口饭吃。



# git的一些基本概念
总体上来说，git是有一些复杂的，暂存区，分支，HEAD指针，rebase,merge，一下会有很多的概念。
首先，git的一个特性就是，它管理的是“修改”本身，而是文件。git保存了文件的一个基础版本并维护了针对该文件的所有修改，而不是为文件的每个历史版本做一个记录。这也似git速度快的一个主要原因。

unix是有diff和patch工具的，同样，linux也有。早些年的linux开发中，linus就是使用这两个工具来手动合并代码修改的。估计是长期手动合并代码的后遗症，linus设计git的时候就引入了这两个备受他信赖的工具，作为git的基础。git就是一整套构建于diff，patch，hash-1基础之上的“修改历史”数据库，我们通过git命令操作这个数据库，来方便地管理我们的程序版本。git上各种眼花缭乱的操作，branch，rebase，merge等等，都和git的这种底层设计密不可分。

关于git的叙述，可以写出几本书，对于有志于系统地学习git使用的同学，简爱那一阅读这些书以获得系统的知识。本文只git的一个简单介绍。个人认为，用过svn的人对git最大的不理解来自于git的 "add commit"的提交方式。每个文件必须通过add添加到版本库，然后使用commit提交。很多git的新手会产生这样的疑惑：为什么要把提交分成两步？这个设计的背后其实涉及到git的一组核心概念:

**工作区，暂存区 ，版本库**

{% asset_img git-stage.png git存储区 %}

从上图可以看到，左侧为工作区，右侧版本库中，标记index的是暂存区，标记为master的则是master分支所包含的目录树。objects则是git的对象，它包含我们对文件的修改，文件目录，commit提交信息，tags等信息，它才是git中实际存储的内容。git使用索引的方式将git对象组织起来，最终呈现给我们的就是一个具体的代码版本。

git中，git的数据库位于我们执行git init的根目录中，是一个名为.git的隐藏文件夹。工作区就是我们进行编码工作的地方，它位于版本库之外。当我们执行git add添加了某个文件之后，git就会把我们针对该文件的修改生成objects对象，这样这个修改就进入了暂存区。暂存区的内容还没有被有效地组织起来，所以我们使用git status，git仍然会提示这些文件，它们的状态被标记为added。理解了这个概念，现在想想，为什么当我们添加了大量的新文件的时候，git会卡？因为git忙着为每个被添加的文件执行diff，比较差异并生成相应的对象存放到暂存区。当我们执行commit提交之后，git会生成一个commit对象来引用我们所有的修改以此来将修改从暂存区真正地提交到版本库中。这个提交同时持有它的父提交的hash-1值。这样提交就可以被正确地索引，我们的提交历史也会被正确地组织起来。

大致有这个印象之后，我们就可以立即一些git操作背后的魔法，比如git checkout仅仅是从git版本库中提取指定文件的指定版本覆盖到工作区。git branch也仅仅是添加一个branch指针指向了某个固定的commit等等。

git的一切“魔法”都基于git的这种组织机构来实现。


git是linus为自己设计的用以管理linux内核的工具。它是久经考验的，它分布式的管理方式和方便的分支切换工作流程，强大的多分支合并和历史回溯功能特别适合于大规模的协作开发。git的威力在linux内核代码管理上得到了充分的验证。

# 结束语
这篇的内容不算很长，我们还没有讲过git的一些基础操作，就这样草草结束好像不是太好。不过也也没关系，git说到底还是一个工具，一个提高程序员生产力并在必要时候保护他们脆弱饭碗的方式。对于工具的学习，更多时候是靠着不断的使用来巩固和提高的。

如果你在实际项目中使用git并且你的开发团队能够正确地使用它，相信你很快就能学会git的使用并惊叹于它的灵活和强大。如果有机会，我想我们会在后续讨论一些git的使用技巧。git中的一些看似神奇的高端操作，正式它有别于其它版本控制工具的关键。掌握了它们，才不会让git明珠蒙尘。


看着项目组其它人熟练地使用git命令行来操作git，真的惊叹于git命令行的神奇，其作为一个命令行管理工具，自有其道理。git命令行相比于GUI工具，有着更大的灵活性和便利性，值得每个希望深入使用git的开发人员认真学习。
