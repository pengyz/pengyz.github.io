---
title: 线程安全问题探讨-并发，同步和线程安全
date: 2017-05-01 20:20:00
updated: 2017-05-01 20:20:00
tags:
- C++
- 并发
- 线程安全
categories:
- C++
---

如果你不确定，请先停下来，自己考虑这个问题并审视你的代码，直到你确定答案是YES。如果我们不能保证基本的线程安全，那我们可能要面临一个定时炸弹：程序可能会在一个只有天知道的时间点崩溃。

很多人对这种多线程bug感到痛苦而绝望，因为它总在不经意间让你的程序变得一团糟。

# 为什么存在“线程安全”问题。

从"线程"的语义上来说，可以理解为在一个进程中提供的多条代码执行路径。在概念上，进程是拥有资源的最小单位，线程是CPU调度的最小单位。在进程中，多个线程可以共享相同的资源。这种“共享”本身就带来了多线程编程中的**线程安全**问题。

<!-- more -->

## 1. 从系统底层看问题-抢占式多任务带来的写入困境

如果我们在多个线程中给一个变量赋值，会存在什么问题？

假设我们有一个变量int i = 10；它能被线程t1和t2之间共享访问。t1和t2都会对i的值进行写入。假设我们在单核上运行这个程序，则系统需要给两个线程都分配cpu时间片。

1. 假设t1从内存中读取了i的值，此时i是10，它把i的值+1，准备把11这个新值写入到内存中。 此时它的时间片耗尽
2. 系统执行了线程调度，t1的执行现场被保存，t2获得执行。它也去读取i的值，此时i的值仍然是10，它也把i的值+1，然后把11写入了内存中。
3. t1再次被调度，此时它也把11写入了内存中。

这里我们就会发现问题：

由于线程调度的不可预测性，我们在多线程中对共享变量的写入出现了错误，程序的执行期行为和编程者的预期不符。

上述讨论发生在单核cpu上，单核cpu的中断发生在指令边缘，只要能在一条指令中完成的操作就不会存在被打断的风险，也就不存在上述的**写入困境**。但是在多核时代，单条指令也会受到干扰。其根源是存在共享变量的代码并不是“可重入”的，对这种代码的执行结果受到执行顺序的影响。


## 2. 从语义层看问题-状态的一致性

在程序的执行过程中，我们期望能够获得一致的状态，但是多线程会破坏这种状态，参考下面的例子：


假设我们写了有个小游戏，在这个游戏中，我们对着一个Monster开火，每次命中monster后减少它的hp，如果hp为0，则修改死亡标志位，杀掉它。
monster可能有如下的定义：
```` C++
struct Monster{
    bool bDie;
    int currHp;
    int maxHp;
};
````
我们使用另一个线程检测monster的状态，一旦发现monster已死亡(currHp = 0或者bDie = true)，我们就让它重生，重置它的hp为maxHp，并修改死亡标志位为false。然后程序按如下的情况执行:

1. 某次攻击后，currHp = 0,攻击线程准备将bDie修改为true，但是此时发生了线程调度，bDie标志位还没有被修改。
2. 复活线程被调度，它发现currHp = 0，然后执行复活monster的逻辑：
    ```` C++
    bDie = false;
    currHp = maxHp;
    ````
3. 攻击线程再次被调度，它执行了上次被打断的动作，修改了bDie为true。

然后，我们得到了一个currHp不为0但是却已经“死亡”的monster对象。这种情况就是一种典型的语义中间态，虽然变量本身的值不存在问题，但是它们却构成了一个非法的组合，有违语义正确性。

# 解决之道

## 1. 系统层面的保证-原子操作

操作系统会提供"原子操作"来解决多线程写入带来的不一致问题。

原子操作保证这个操作在执行时不会被打断，它所操作的资源也不会被其它核心访问和修改。对具体实现方式感兴趣的同学可以参考[linux内核原子操作的实现](http://blog.csdn.net/vividonly/article/details/6599502)：

> 在X86平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU上有一根引线#HLOCK pin连到北桥，如果汇编语言的程序中在一条指令前面加上前缀"LOCK"，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。对于其他平台的CPU，实现各不相同，有的是通过关中断来实现原子操作（sparc），有的通过CMPXCHG系列的指令来实现原子操作（IA64）。

## 2. 语义保证-锁机制

**锁**是一个实现于操作系统内核中的机制，它保证同一时间只能有一个线程获取锁的所有权，其它的线程则阻塞，等待上一个线程释放锁后，重新竞争**锁**的所有权,胜利者得以执行，失败者等待下一轮竞争。

当我们在多线程中访问共享资源时，所有的访问点都必须使用锁来锁定，共同竞争对资源的访问权。这种机制提供了一个在多线程之间**排队**的机制：对共享资源的访问实际是*单线程*的，同一时间只有一个线程在访问资源。这也就是我们所谓的**线程同步**。

锁机制其实带来了一些资源的浪费，降低了多线程程序在临界资源上的运行效率。而且它引入的**死锁**问题同样让人头疼不已。


# 新思路

长久以来多线程编程中的问题给程序员的生活平添了无数的bug。针对这个问题，也许我们可以从多线程并发的根源考虑，大概有两条路：

1. 函数式编程，消灭共享状态。典型代表：haskell
2. 异步编程，消灭多线程。典型代表：nodejs



# 参考资料

本文引用了如下资料，如原作者对此行为有任何异议，请联系本人撤销。

[linux内核原子操作的实现](http://blog.csdn.net/vividonly/article/details/6599502)
